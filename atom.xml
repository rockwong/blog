<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Web Library]]></title>
  <link href="http://rockwong.com/atom.xml" rel="self"/>
  <link href="http://rockwong.com/"/>
  <updated>2018-12-26T00:37:32+08:00</updated>
  <id>http://rockwong.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[学习笔记]]></title>
    <link href="http://rockwong.com/15457014993763.html"/>
    <updated>2018-12-25T09:31:39+08:00</updated>
    <id>http://rockwong.com/15457014993763.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">MySql</h2>

<p>node 操作数据库</p>

<ol>
<li><code>npm install mysql</code></li>
<li><code>const db=mysql.createConnection(host,port,user,password,database)</code></li>
<li><code>db.query(SQL,(err,data)=&gt;{}))</code></li>
<li>SQL 语句 增删改查</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发实践]]></title>
    <link href="http://rockwong.com/15453151087296.html"/>
    <updated>2018-12-20T22:11:48+08:00</updated>
    <id>http://rockwong.com/15453151087296.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">使用 Typescript 时</h2>

<h3 id="toc_1">ts-node 来调试代码</h3>

<blockquote>
<p><a href="https://github.com/TypeStrong/ts-node">https://github.com/TypeStrong/ts-node</a></p>
</blockquote>

<p><code>ts-node</code> 可以直接来调试.ts代码</p>

<pre><code class="language-bash">npm install -g ts-node
ts-node script.ts
</code></pre>

<h3 id="toc_2">tsconfig-paths</h3>

<p>使用 <code>tsconfig-paths</code> 来 fixed <code>paths</code> 找不到产生的 module 错误  “Cannot find module”</p>

<pre><code class="language-bash">npm install --save-dev tsconfig-paths

node -r tsconfig-paths/register main.js
ts-node -r tsconfig-paths/register main.ts
</code></pre>

<h3 id="toc_3">在webstorm 的 debug 中</h3>

<p>配置debug <code>Node parameters</code> 为<code>--inspect --require ts-node/register</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[npm scripts 使用指南]]></title>
    <link href="http://rockwong.com/15452167793670.html"/>
    <updated>2018-12-19T18:52:59+08:00</updated>
    <id>http://rockwong.com/15452167793670.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html">http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html</a></p>
</blockquote>

<h2 id="toc_0">原理</h2>

<p>每当执行<code>npm run</code>，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。</p>

<p>比较特别的是，<code>npm run</code>新建的这个 Shell，会将当前目录的<code>node_modules/.bin</code>子目录加入<code>PATH</code>变量，执行结束后，再将<code>PATH</code>变量恢复原样。</p>

<p>这意味着，当前目录的<code>node_modules/.bin</code>子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写<code>mocha test</code>就可以了。</p>

<pre><code class="language-javascript">&quot;test&quot;: &quot;mocha test&quot;
</code></pre>

<p>而不用写成下面这样。</p>

<pre><code class="language-javascript">&quot;test&quot;: &quot;./node_modules/.bin/mocha test&quot;
</code></pre>

<p>由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。</p>

<p>npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是<code>0</code>，npm 就认为这个脚本执行失败。</p>

<h2 id="toc_1">通配符</h2>

<p>由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。</p>

<pre><code class="language-javascript">&quot;lint&quot;: &quot;jshint *.js&quot;
&quot;lint&quot;: &quot;jshint **/*.js&quot;
</code></pre>

<p>上面代码中，<code>*</code>表示任意文件名，<code>**</code>表示任意一层子目录。</p>

<p>如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。</p>

<pre><code class="language-javascript">&quot;test&quot;: &quot;tap test/\*.js&quot;
</code></pre>

<h2 id="toc_2">传参</h2>

<p>向 npm 脚本传入参数，要使用<code>--</code>标明。</p>

<pre><code class="language-javascript">&quot;lint&quot;: &quot;jshint **.js&quot;
</code></pre>

<p>向上面的<code>npm run lint</code>命令传入参数，必须写成下面这样。</p>

<pre><code class="language-bash">$ npm run lint --  --reporter checkstyle &gt; checkstyle.xml
</code></pre>

<p>也可以在<code>package.json</code>里面再封装一个命令。</p>

<pre><code class="language-javascript">&quot;lint&quot;: &quot;jshint **.js&quot;,
&quot;lint:checkstyle&quot;: &quot;npm run lint -- --reporter checkstyle &gt; checkstyle.xml&quot;
</code></pre>

<h2 id="toc_3">执行顺序</h2>

<p>如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p>

<p>如果是并行执行（即同时的平行执行），可以使用<code>&amp;</code>符号。</p>

<pre><code class="language-bash">$ npm run script1.js &amp; npm run script2.js
</code></pre>

<p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用<code>&amp;&amp;</code>符号。</p>

<pre><code class="language-bash">$ npm run script1.js &amp;&amp; npm run script2.js
</code></pre>

<p>这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：<a href="https://github.com/paulpflug/script-runner">script-runner</a>、<a href="https://github.com/mysticatea/npm-run-all">npm-run-all</a>、<a href="https://github.com/coderaiser/redrun">redrun</a>。</p>

<h2 id="toc_4">默认值</h2>

<p>一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。</p>

<pre><code class="language-javascript">&quot;start&quot;: &quot;node server.js&quot;，
&quot;install&quot;: &quot;node-gyp rebuild&quot;
</code></pre>

<p>上面代码中，<code>npm run start</code>的默认值是<code>node server.js</code>，前提是项目根目录下有<code>server.js</code>这个脚本；<code>npm run install</code>的默认值是<code>node-gyp rebuild</code>，前提是项目根目录下有<code>binding.gyp</code>文件。</p>

<h2 id="toc_5">钩子</h2>

<p>npm 脚本有<code>pre</code>和<code>post</code>两个钩子。举例来说，<code>build</code>脚本命令的钩子就是<code>prebuild</code>和<code>postbuild</code>。</p>

<pre><code class="language-javascript">&quot;prebuild&quot;: &quot;echo I run before the build script&quot;,
&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;,
&quot;postbuild&quot;: &quot;echo I run after the build script&quot;
</code></pre>

<p>用户执行<code>npm run build</code>的时候，会自动按照下面的顺序执行。</p>

<pre><code class="language-bash">npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild
</code></pre>

<p>因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。</p>

<pre><code class="language-javascript">&quot;clean&quot;: &quot;rimraf ./dist &amp;&amp; mkdir dist&quot;,
&quot;prebuild&quot;: &quot;npm run clean&quot;,
&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;
</code></pre>

<p>npm 默认提供下面这些钩子。</p>

<blockquote>
<ul>
<li>prepublish，postpublish</li>
<li>preinstall，postinstall</li>
<li>preuninstall，postuninstall</li>
<li>preversion，postversion</li>
<li>pretest，posttest</li>
<li>prestop，poststop</li>
<li>prestart，poststart</li>
<li>prerestart，postrestart</li>
</ul>
</blockquote>

<p>自定义的脚本命令也可以加上<code>pre</code>和<code>post</code>钩子。比如，<code>myscript</code>这个脚本命令，也有<code>premyscript</code>和<code>postmyscript</code>钩子。不过，双重的<code>pre</code>和<code>post</code>无效，比如<code>prepretest</code>和<code>postposttest</code>是无效的。</p>

<p>npm 提供一个<code>npm_lifecycle_event</code>变量，返回当前正在运行的脚本名称，比如<code>pretest</code>、<code>test</code>、<code>posttest</code>等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的<code>npm scripts</code>命令编写代码。请看下面的例子。</p>

<pre><code class="language-javascript">const TARGET = process.env.npm_lifecycle_event;

if (TARGET === &#39;test&#39;) {
  console.log(`Running the test task!`);
}

if (TARGET === &#39;pretest&#39;) {
  console.log(`Running the pretest task!`);
}

if (TARGET === &#39;posttest&#39;) {
  console.log(`Running the posttest task!`);
}
</code></pre>

<p>注意，<code>prepublish</code>这个钩子不仅会在<code>npm publish</code>命令之前运行，还会在<code>npm install</code>（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子<code>prepare</code>，行为等同于<code>prepublish</code>，而从 npm 5 开始，<code>prepublish</code>将只在<code>npm publish</code>命令之前运行。</p>

<h2 id="toc_6">简写形式</h2>

<p>四个常用的 npm 脚本有简写形式。</p>

<blockquote>
<ul>
<li><code>npm start</code>是<code>npm run start</code></li>
<li><code>npm stop</code>是<code>npm run stop</code>的简写</li>
<li><code>npm test</code>是<code>npm run test</code>的简写</li>
<li><code>npm restart</code>是<code>npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start</code>的简写</li>
</ul>
</blockquote>

<p><code>npm start</code>、<code>npm stop</code>和<code>npm restart</code>都比较好理解，而<code>npm restart</code>是一个复合命令，实际上会执行三个脚本命令：<code>stop</code>、<code>restart</code>、<code>start</code>。具体的执行顺序如下。</p>

<blockquote>
<ol>
<li>prerestart</li>
<li>prestop</li>
<li>stop</li>
<li>poststop</li>
<li>restart</li>
<li>prestart</li>
<li>start</li>
<li>poststart</li>
<li>postrestart </li>
</ol>
</blockquote>

<h2 id="toc_7">变量</h2>

<p>npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。</p>

<p>首先，通过<code>npm_package_</code>前缀，npm 脚本可以拿到<code>package.json</code>里面的字段。比如，下面是一个<code>package.json</code>。</p>

<pre><code class="language-javascript">{
  &quot;name&quot;: &quot;foo&quot;, 
  &quot;version&quot;: &quot;1.2.5&quot;,
  &quot;scripts&quot;: {
    &quot;view&quot;: &quot;node view.js&quot;
  }
}
</code></pre>

<p>那么，变量<code>npm_package_name</code>返回<code>foo</code>，变量<code>npm_package_version</code>返回<code>1.2.5</code>。</p>

<pre><code class="language-javascript">// view.js
console.log(process.env.npm_package_name); // foo
console.log(process.env.npm_package_version); // 1.2.5
</code></pre>

<p>上面代码中，我们通过环境变量<code>process.env</code>对象，拿到<code>package.json</code>的字段值。如果是 Bash 脚本，可以用<code>$npm_package_name</code>和<code>$npm_package_version</code>取到这两个值。</p>

<p><code>npm_package_</code>前缀也支持嵌套的<code>package.json</code>字段。</p>

<pre><code class="language-javascript">  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;xxx&quot;
  },
  scripts: {
    &quot;view&quot;: &quot;echo $npm_package_repository_type&quot;
  }
</code></pre>

<p>上面代码中，<code>repository</code>字段的<code>type</code>属性，可以通过<code>npm_package_repository_type</code>取到。</p>

<p>下面是另外一个例子。</p>

<pre><code class="language-javascript">&quot;scripts&quot;: {
  &quot;install&quot;: &quot;foo.js&quot;
}
</code></pre>

<p>上面代码中，<code>npm_package_scripts_install</code>变量的值等于<code>foo.js</code>。</p>

<p>然后，npm 脚本还可以通过<code>npm_config_</code>前缀，拿到 npm 的配置变量，即<code>npm config get xxx</code>命令返回的值。比如，当前模块的发行标签，可以通过<code>npm_config_tag</code>取到。</p>

<pre><code class="language-javascript">&quot;view&quot;: &quot;echo $npm_config_tag&quot;,
</code></pre>

<p>注意，<code>package.json</code>里面的<code>config</code>对象，可以被环境变量覆盖。</p>

<pre><code class="language-javascript">{ 
  &quot;name&quot; : &quot;foo&quot;,
  &quot;config&quot; : { &quot;port&quot; : &quot;8080&quot; },
  &quot;scripts&quot; : { &quot;start&quot; : &quot;node server.js&quot; }
}
</code></pre>

<p>上面代码中，<code>npm_package_config_port</code>变量返回的是<code>8080</code>。这个值可以用下面的方法覆盖。</p>

<pre><code class="language-bash">$ npm config set foo:port 80
</code></pre>

<p>最后，<code>env</code>命令可以列出所有环境变量。</p>

<pre><code class="language-javascript">&quot;env&quot;: &quot;env&quot;
</code></pre>

<h2 id="toc_8">常用脚本示例</h2>

<pre><code class="language-javascript">// 删除目录
&quot;clean&quot;: &quot;rimraf dist/*&quot;,

// 本地搭建一个 HTTP 服务
&quot;serve&quot;: &quot;http-server -p 9090 dist/&quot;,

// 打开浏览器
&quot;open:dev&quot;: &quot;opener http://localhost:9090&quot;,

// 实时刷新
 &quot;livereload&quot;: &quot;live-reload --port 9091 dist/&quot;,

// 构建 HTML 文件
&quot;build:html&quot;: &quot;jade index.jade &gt; dist/index.html&quot;,

// 只要 CSS 文件有变动，就重新执行构建
&quot;watch:css&quot;: &quot;watch &#39;npm run build:css&#39; assets/styles/&quot;,

// 只要 HTML 文件有变动，就重新执行构建
&quot;watch:html&quot;: &quot;watch &#39;npm run build:html&#39; assets/html&quot;,

// 部署到 Amazon S3
&quot;deploy:prod&quot;: &quot;s3-cli sync ./dist/ s3://example-com/prod-site/&quot;,

// 构建 favicon
&quot;build:favicon&quot;: &quot;node scripts/favicon.js&quot;,
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[按位操作符（Bitwise operators）]]></title>
    <link href="http://rockwong.com/15450317412604.html"/>
    <updated>2018-12-17T15:29:01+08:00</updated>
    <id>http://rockwong.com/15450317412604.html</id>
    <content type="html"><![CDATA[
<p>将其操作数（operands）当作32位的比特序列（由0和1组成），而不是十进制、十六进制或八进制数值.</p>

<table>
<thead>
<tr>
<th>运算符</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>按位与（ AND）</td>
<td>a &amp; b</td>
<td>对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。</td>
</tr>
<tr>
<td>按位或（OR）</td>
<td>a</td>
<td>b</td>
</tr>
<tr>
<td>按位异或（XOR）</td>
<td>a ^ b</td>
<td>对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。</td>
</tr>
<tr>
<td>按位非（NOT）</td>
<td>~ a</td>
<td>反转操作数的比特位，即0变成1，1变成0。</td>
</tr>
<tr>
<td>左移（Left shift）</td>
<td>a &lt;&lt; b</td>
<td>将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用0填充。</td>
</tr>
<tr>
<td>有符号右移</td>
<td>a &gt;&gt; b</td>
<td>将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位。</td>
</tr>
<tr>
<td>无符号右移</td>
<td>a &gt;&gt;&gt; b</td>
<td>将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。</td>
</tr>
</tbody>
</table>

<h2 id="toc_0">操作符掩码</h2>

<pre><code class="language-javascript">    
    // 多个场景统计，只统计一次
    var screenTrackFlag = 0;  // 跟踪场景（index）的统计情况
   function trackScreen(screenIndex) {
        var screenBit = (1 &lt;&lt; screenIndex);  // 1 左移 场景的index，即当前场景的二进制
        if ((screenTrackFlag &amp; screenBit) == 0) {   // 场景的二进制与screenTrackFlag对比，确认没有执行过
            screenTrackFlag = screenTrackFlag | screenBit;
        }
    }
</code></pre>

<h2 id="toc_1">取整</h2>

<p><code>1.23&lt;&lt;0</code> 左移运算符 ，舍弃小数部分<br/>
<code>1.23&gt;&gt;0</code> 右移运算符，舍弃小数部分</p>

<h2 id="toc_2">值交换</h2>

<pre><code class="language-text">var a = 5
var b = 8
a ^= b
b ^= a
a ^= b
console.log(a)   // 8
console.log(b)   // 5
</code></pre>

<h2 id="toc_3">使用&amp;, &gt;&gt;, |来完成rgb值和16进制颜色值之间的转换</h2>

<pre><code class="language-javascript">/**
 * 16进制颜色值转RGB
 * @param  {String} hex 16进制颜色字符串
 * @return {String}     RGB颜色字符串
 */
  function hexToRGB(hex) {
    var hexx = hex.replace(&#39;#&#39;, &#39;0x&#39;)
    var r = hexx &gt;&gt; 16
    var g = hexx &gt;&gt; 8 &amp; 0xff
    var b = hexx &amp; 0xff
    return `rgb(${r}, ${g}, ${b})`
}

/**
 * RGB颜色转16进制颜色
 * @param  {String} rgb RGB进制颜色字符串
 * @return {String}     16进制颜色字符串
 */
function RGBToHex(rgb) {
    var rgbArr = rgb.split(/[^\d]+/)
    var color = rgbArr[1]&lt;&lt;16 | rgbArr[2]&lt;&lt;8 | rgbArr[3]
    return &#39;#&#39;+ color.toString(16)
}
// -------------------------------------------------
hexToRGB(&#39;#ffffff&#39;)               // &#39;rgb(255,255,255)&#39;
RGBToHex(&#39;rgb(255,255,255)&#39;)      // &#39;#ffffff&#39;

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[预定义的有条件类型]]></title>
    <link href="http://rockwong.com/15450286491100.html"/>
    <updated>2018-12-17T14:37:29+08:00</updated>
    <id>http://rockwong.com/15450286491100.html</id>
    <content type="html"><![CDATA[
<ul>
<li><code>Exclude&lt;T, U&gt;</code> -- 从<code>T</code>中剔除可以赋值给<code>U</code>的类型。</li>
<li><code>Extract&lt;T, U&gt;</code> -- 提取<code>T</code>中可以赋值给<code>U</code>的类型。</li>
<li><code>NonNullable&lt;T&gt;</code> -- 从<code>T</code>中剔除<code>null</code>和<code>undefined</code>。</li>
<li><code>ReturnType&lt;T&gt;</code> -- 获取函数返回值类型。</li>
<li><code>InstanceType&lt;T&gt;</code> -- 获取构造函数类型的实例类型。</li>
</ul>

<h2 id="toc_0">示例</h2>

<pre><code class="language-ts">type T00 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;, &quot;a&quot; | &quot;c&quot; | &quot;f&quot;&gt;;  // &quot;b&quot; | &quot;d&quot;
type T01 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;, &quot;a&quot; | &quot;c&quot; | &quot;f&quot;&gt;;  // &quot;a&quot; | &quot;c&quot;

type T02 = Exclude&lt;string | number | (() =&gt; void), Function&gt;;  // string | number
type T03 = Extract&lt;string | number | (() =&gt; void), Function&gt;;  // () =&gt; void

type T04 = NonNullable&lt;string | number | undefined&gt;;  // string | number
type T05 = NonNullable&lt;(() =&gt; string) | string[] | null | undefined&gt;;  // (() =&gt; string) | string[]

function f1(s: string) {
    return { a: 1, b: s };
}

class C {
    x = 0;
    y = 0;
}

type T10 = ReturnType&lt;() =&gt; string&gt;;  // string
type T11 = ReturnType&lt;(s: string) =&gt; void&gt;;  // void
type T12 = ReturnType&lt;(&lt;T&gt;() =&gt; T)&gt;;  // {}
type T13 = ReturnType&lt;(&lt;T extends U, U extends number[]&gt;() =&gt; T)&gt;;  // number[]
type T14 = ReturnType&lt;typeof f1&gt;;  // { a: number, b: string }
type T15 = ReturnType&lt;any&gt;;  // any
type T16 = ReturnType&lt;never&gt;;  // any
type T17 = ReturnType&lt;string&gt;;  // Error
type T18 = ReturnType&lt;Function&gt;;  // Error

type T20 = InstanceType&lt;typeof C&gt;;  // C
type T21 = InstanceType&lt;any&gt;;  // any
type T22 = InstanceType&lt;never&gt;;  // any
type T23 = InstanceType&lt;string&gt;;  // Error
type T24 = InstanceType&lt;Function&gt;;  // Error
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[索引类型（Index types）]]></title>
    <link href="http://rockwong.com/15450169930004.html"/>
    <updated>2018-12-17T11:23:13+08:00</updated>
    <id>http://rockwong.com/15450169930004.html</id>
    <content type="html"><![CDATA[
<p>js 函数</p>

<pre><code class="language-javascript">function pluck(o, names) {
    return names.map(n =&gt; o[n]);
}
</code></pre>

<p>TypeScript 中声明和使用</p>

<pre><code class="language-ts">function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] {
  return names.map(n =&gt; o[n]);
}

interface Person {
    name: string;
    age: number;
}
let person: Person = {
    name: &#39;Jarid&#39;,
    age: 35
};
let strings: string[] = pluck(person, [&#39;name&#39;]); // ok, string[]
</code></pre>

<h3 id="toc_0">索引类型查询操作符</h3>

<p><code>keyof T</code> ,上例为已知公共属性名的联合</p>

<p><code>let personProps: keyof Person; // &#39;name&#39; | &#39;age&#39;</code></p>

<h3 id="toc_1">索引访问操作符</h3>

<p><code>T[K]</code> 需要确保 <code>K extends keyof T</code></p>

<pre><code class="language-ts">function getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] {
    return o[name]; // o[name] is of type T[K]
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型保护与区分类型]]></title>
    <link href="http://rockwong.com/15447850684255.html"/>
    <updated>2018-12-14T18:57:48+08:00</updated>
    <id>http://rockwong.com/15447850684255.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">类型保护</h2>

<p>检查方法成员是否存在，需要使用断言以保证不会报错</p>

<pre><code class="language-ts">let pet = getSmallPet();

if ((&lt;Fish&gt;pet).swim) {
    (&lt;Fish&gt;pet).swim();
}
else {
    (&lt;Bird&gt;pet).fly();
}
</code></pre>

<p>类型谓词为 <code>parameterName is Type</code>形式</p>

<pre><code class="language-ts">// check 类型
function isFish(pet: Fish | Bird): pet is Fish {
    return (&lt;Fish&gt;pet).swim !== undefined;
}

// &#39;swim&#39; 和 &#39;fly&#39; 调用都没有问题了
// TypeScript不仅知道在 if分支里 pet是 Fish类型； 它还清楚在 else分支里，一定 不是 Fish类型，一定是 Bird类型

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
</code></pre>

<p><strong><code>typeof</code>的类型保护</strong></p>

<p>TS默认 typeof 为类型保护，必须满足以下条件</p>

<ol>
<li>typeof v === &quot;typename&quot; 和 typeof v !== &quot;typename&quot;</li>
<li>typename 必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;</li>
</ol>

<p><strong><code>instanceof</code>的类型保护</strong></p>

<pre><code class="language-ts">class Foo {
  foo = 123;
}

class Bar {
  bar = 123;
}

function doStuff(arg: Foo | Bar) {
  if (arg instanceof Foo) {
    console.log(arg.foo); // ok
    console.log(arg.bar); // Error
  } else {
    // 这个块中，一定是 &#39;bar&#39;
    console.log(arg.foo); // Error
    console.log(arg.bar); // ok
  }
}

doStuff(new Foo());
doStuff(new Bar());
</code></pre>

<p><code>in</code></p>

<p><code>in</code> 操作符可以安全的检查一个对象上是否存在一个属性，它通常也被做为类型保护使用：</p>

<pre><code class="language-ts">interface A {
  x: number;
}

interface B {
  y: string;
}

function doStuff(q: A | B) {
  if (&#39;x&#39; in q) {
    // q: A
  } else {
    // q: B
  }
}
</code></pre>

<p><strong><code>!</code>后缀的类型断言去除<code>null</code> 或 <code>undefined</code></strong></p>

<pre><code class="language-ts">function fixed(name: string | null): string {
  function postfix(epithet: string) {
    return name!.charAt(0) + &#39;.  the &#39; + epithet; // ok
  }
  name = name || &quot;Bob&quot;;
  return postfix(&quot;great&quot;);
}
</code></pre>

<p><code>可辨识联合（Discriminated Unions）</code></p>

<ol>
<li>具有普通的单例类型属性— 可辨识的特征。</li>
<li>一个类型别名包含了那些类型的联合— 联合。</li>
<li>此属性上的类型保护。</li>
</ol>

<pre><code class="language-ts">interface Square {
    kind: &quot;square&quot;;
    size: number;
}
interface Rectangle {
    kind: &quot;rectangle&quot;;
    width: number;
    height: number;
}
interface Circle {
    kind: &quot;circle&quot;;
    radius: number;
}

type Shape = Square | Rectangle | Circle;

function area(s: Shape) {
    switch (s.kind) {
        case &quot;square&quot;: return s.size * s.size;
        case &quot;rectangle&quot;: return s.height * s.width;
        case &quot;circle&quot;: return Math.PI * s.radius ** 2;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Now.sh 免费部署项目]]></title>
    <link href="http://rockwong.com/15360262436245.html"/>
    <updated>2018-09-04T09:57:23+08:00</updated>
    <id>http://rockwong.com/15360262436245.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">about</h2>

<p>ZEIT是美国一家提供云部署服务的公司，旗下的 Now.sh提供了Realtime global deployments(全球化实时部署)服务。</p>

<h2 id="toc_1">免费的 OSS 服务</h2>

<table>
<thead>
<tr>
<th style="text-align: right">名称</th>
<th>配置</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: right">带宽</td>
<td>1GB*</td>
</tr>
<tr>
<td style="text-align: right">日志</td>
<td>100MB*</td>
</tr>
<tr>
<td style="text-align: right">部署</td>
<td>∞</td>
</tr>
<tr>
<td style="text-align: right">并发实例</td>
<td>3</td>
</tr>
<tr>
<td style="text-align: right">CDN 域名</td>
<td>不支持</td>
</tr>
<tr>
<td style="text-align: right">域</td>
<td>∞</td>
</tr>
<tr>
<td style="text-align: right">MAX文件大小/存储空间</td>
<td>5MB / 1GB</td>
</tr>
<tr>
<td style="text-align: right">自动增长支持</td>
<td>不支持</td>
</tr>
<tr>
<td style="text-align: right">团队协作人数</td>
<td>支持</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">使用步骤</h2>

<pre><code class="language-bash"># 安装
npm install -g now

#登录,需在邮件中确认
now login
</code></pre>

<h2 id="toc_3">部署</h2>

<p><code>static</code></p>

<pre><code class="language-bash"> projectdir/ now
</code></pre>

<p><code>Node.js 部署</code></p>

<p>部署命令与静态资源一样，但应用程序目录中有一个package.json文件，那么Now.sh会认为有效的Node.js部署。这是一个简单的Node.js部署在微服务</p>

<p>Node.js 应用必须要用以下两个文件才能被 Now.sh 识别。</p>

<p>示例代码：index.js</p>

<pre><code class="language-javascript">module.exports = () =&gt; ({
  date: new Date
})
</code></pre>

<p>示例代码：package.json</p>

<pre><code class="language-javascript">{
  &quot;name&quot;: &quot;get-started-node&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;dependencies&quot;: {
    &quot;micro&quot;: &quot;latest&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;micro&quot;
  }
}
</code></pre>

<p><code>Docker 部署</code></p>

<p>应用程序目录包含一个Docker文件，那么现在考虑一个有效的Docker部署。它将基于Dockerfile构建一个docker映像，并基于此启动容器。</p>

<p>部署一个简单的Go HTTP服务器，创建一个目录并添加这两个文件：</p>

<p>示例代码： hello.go</p>

<pre><code class="language-go">package main

import (
    &quot;io&quot;
    &quot;net/http&quot;
)

func main() {
    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
        io.WriteString(w, &quot;Hello world!&quot;)
    })

    err := http.ListenAndServe(&quot;:8000&quot;, nil)
    if err != nil {
        panic(err)
    }
}
</code></pre>

<p>示例代码： Dockerfile</p>

<pre><code class="language-text">FROM golang:alpine
ADD . /go/src/zeit/hello
RUN go install zeit/hello
CMD [&quot;/go/bin/hello&quot;]
EXPOSE 8000
</code></pre>

<p><code>部署总结：</code></p>

<p>项目在部署完成之后，我们会得到一个链接，可以通过这个链接来访问部署的项目。</p>

<p>每次更新部署后， url 都会生成一个新的，但是老的 url 都还是可以用的。如果最终网站要产品化，可以很容易的绑定自己的域名。</p>

<h2 id="toc_4">Now.sh - 域名</h2>

<p><code>now.sh提供的域名</code></p>

<pre><code class="language-bash">#  alias 指定域名
$ now alias https://my-name.now.sh my-web-app

# 发布当前文件夹项目 并 alias 
$ now alias may-web-app
</code></pre>

<p><code>now.sh管理的自定义域名</code></p>

<ol>
<li>如果域名解析的DNS 由 now.sh 托管则，直接使用托管域名即可</li>
<li>如果解析不在now.sh则需要在域名解析商增加 <code>CNAME</code> 记录 值为<code>alias.zeit.co</code>, 然后运行一下命令</li>
</ol>

<pre><code class="language-bash">#  alias 指定域名
$ now alias https://my-web-app-avvuiuuwto.now.sh my-web-app.com

# 发布当前文件夹项目 并 alias 
$ now alias my-web-app.com
</code></pre>

<h2 id="toc_5">注意事项</h2>

<p><code>优势：</code></p>

<ul>
<li>自带的 https</li>
<li>真正的一键部署，不用自己管理服务器，将 severless 进行到底</li>
<li>不翻墙，访问速度很棒</li>
</ul>

<p><code>其他</code></p>

<ul>
<li>为了节省资源，应用一段时间不用就会被 frozen （冻结），但是只要我们去敲链接去访问，就会自动 unfrozen ，只不过初次访问速度会受影响。</li>
<li>在 Now.sh提供的免费服务中，您的代码将是公开的和开源的，如果介意可升级账户或放弃使用。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见错误处理]]></title>
    <link href="http://rockwong.com/15359007579742.html"/>
    <updated>2018-09-02T23:05:57+08:00</updated>
    <id>http://rockwong.com/15359007579742.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">TypeError: Converting circular structure to JSON</h2>

<p>JSON.stringify 出错的问题</p>

<pre><code class="language-javascript">// Demo: Circular reference
var o = {};
o.o = o;

// Note: cache should not be re-used by repeated calls to JSON.stringify.
var cache = [];
JSON.stringify(o, function(key, value) {
    if (typeof value === &#39;object&#39; &amp;&amp; value !== null) {
        if (cache.indexOf(value) !== -1) {
            // Circular reference found, discard key
            return;
        }
        // Store value in our collection
        cache.push(value);
    }
    return value;
});
cache = null;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[node 爬虫]]></title>
    <link href="http://rockwong.com/15355944122228.html"/>
    <updated>2018-08-30T10:00:12+08:00</updated>
    <id>http://rockwong.com/15355944122228.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">维持登录状态</h2>

<p>大部分网站的的登录都是基于<code>cookie</code> 和 <code>session</code> 来进行，所以在爬需要登录的接口时需要获取已登录的的<code>cookie</code>,利用它来伪造登录。</p>

<ol>
<li>登录目标网站，访问需要登录权限的页面</li>
<li>在<code>chrome</code> 的开发者工具中的<code>network</code>中找到需要check登录的请求，并将从 header中找到 <code>cookie</code>的值，复制下来</li>
<li>将复制的<code>cookie</code> 附在爬虫请求的 <code>header</code>中即可伪造登录。</li>
</ol>

<h2 id="toc_1">url 处理</h2>

<p>当<code>url</code>地址中含有中文，无法下载的问题<br/>
<code>encodeURI(downloadUrl)</code></p>

<h2 id="toc_2">存放路径地址</h2>

<p>使用 <code>path</code> 会解决 不同系统下路径访问的问题。<br/>
<code>path.join(pathStr)</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vue router]]></title>
    <link href="http://rockwong.com/15344730078020.html"/>
    <updated>2018-08-17T10:30:07+08:00</updated>
    <id>http://rockwong.com/15344730078020.html</id>
    <content type="html"><![CDATA[
<p>路由配置与react-router 相仿</p>

<h2 id="toc_0">html</h2>

<pre><code class="language-markup">
&lt;div id=&quot;app&quot;&gt;
  &lt;h1&gt;Hello App!&lt;/h1&gt;
  &lt;p&gt;
    &lt;!-- 使用 router-link 组件来导航. --&gt;
    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;
    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;
    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;
    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;
  &lt;/p&gt;
  &lt;!-- 路由出口 --&gt;
  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;
</code></pre>

<h2 id="toc_1">javaScript</h2>

<pre><code class="language-javascript">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)

// 1. 定义 (路由) 组件。
// 可以从其他文件 import 进来
const Foo = { template: &#39;&lt;div&gt;foo&lt;/div&gt;&#39; }
const Bar = { template: &#39;&lt;div&gt;bar&lt;/div&gt;&#39; }

// 2. 定义路由
// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是
// 通过 Vue.extend() 创建的组件构造器，
// 或者，只是一个组件配置对象。
// 我们晚点再讨论嵌套路由。
const routes = [
  { path: &#39;/foo&#39;, component: Foo },
  { path: &#39;/bar&#39;, component: Bar }
]

// 3. 创建 router 实例，然后传 `routes` 配置
// 你还可以传别的配置参数, 不过先这么简单着吧。
const router = new VueRouter({
  routes // (缩写) 相当于 routes: routes
})

// 4. 创建和挂载根实例。
// 记得要通过 router 配置参数注入路由，
// 从而让整个应用都有路由功能
const app = new Vue({
  router
}).$mount(&#39;#app&#39;)

// 现在，应用已经启动了！
</code></pre>

<h2 id="toc_2">组件内部访问路由</h2>

<pre><code class="language-javascript">// Home.vue
export default {
  computed: {
    username () {
      // 我们很快就会看到 `params` 是什么
      return this.$route.params.username
    }
  },
  methods: {
    goBack () {
      window.history.length &gt; 1
        ? this.$router.go(-1)
        : this.$router.push(&#39;/&#39;)
    }
  }
}
</code></pre>

<h2 id="toc_3">响应路由参数的变化</h2>

<ul>
<li> watch <code>$route</code> 对象</li>
</ul>

<pre><code class="language-javascript">const User = {
  template: &#39;...&#39;,
  watch: {
    &#39;$route&#39; (to, from) {
      // 对路由变化作出响应...
    }
  }
}
</code></pre>

<ul>
<li><code>beforeRouteUpdate</code> 钩子函数</li>
</ul>

<pre><code class="language-javascript">const User = {
  template: &#39;...&#39;,
  beforeRouteUpdate (to, from, next) {
    // react to route changes...
    // don&#39;t forget to call next()
  }
}
</code></pre>

<h2 id="toc_4">路由嵌套</h2>

<pre><code class="language-javascript">const User = {
  template: `
    &lt;div class=&quot;user&quot;&gt;
      &lt;h2&gt;User {{ $route.params.id }}&lt;/h2&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  `
}
const router = new VueRouter({
  routes: [
    { path: &#39;/user/:id&#39;, component: User,
      children: [
        {
          // 当 /user/:id/profile 匹配成功，
          // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中
          path: &#39;profile&#39;,
          component: UserProfile
        },
        {
          // 当 /user/:id/posts 匹配成功
          // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中
          path: &#39;posts&#39;,
          component: UserPosts
        }
      ]
    }
  ]
})
</code></pre>

<h2 id="toc_5">router 方法</h2>

<h3 id="toc_6">router.push(location, onComplete?, onAbort?)</h3>

<ol>
<li>在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code></li>
<li>点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 会内部调用 <code>router.push(...)</code> 实现</li>
<li>会想 history 栈添加一个新的记录</li>
</ol>

<pre><code class="language-javascript">// 字符串
router.push(&#39;home&#39;)

// 命名的路由，如果参数对象中含有path,则会忽略 params
router.push({ name: &#39;user&#39;, params: { userId: 123 }}) // -&gt; /user/123
//同 &lt;router-link :to=&quot;{ name: &#39;user&#39;, params: { userId: 123 }}&quot;&gt;User&lt;/router-link&gt;

// 带查询参数，变成 /register?plan=private
router.push({ path: &#39;register&#39;, query: { plan: &#39;private&#39; }})
</code></pre>

<h3 id="toc_7">router.replace(location, onComplete?, onAbort?)</h3>

<p>同<code>router.push</code>,不会将 history 放入栈记录中。</p>

<h3 id="toc_8">router.go(n)</h3>

<p>参数是一个整数在 history 记录中向前或者后退多少步，类似 window.history.go(n)</p>

<h2 id="toc_9">视图命名 <router-view name="a" /></h2>

<p>在根目录时分别展示：</p>

<ol>
<li>view 为 default的<code>Foo</code>组件</li>
<li>view 为 a 的<code>Bar</code>组件</li>
<li>view 为 b的<code>Baz</code>组件</li>
</ol>

<pre><code class="language-jsx">const Foo = { template: &#39;&lt;div&gt;foo&lt;/div&gt;&#39; }
const Bar = { template: &#39;&lt;div&gt;bar&lt;/div&gt;&#39; }
const Baz = { template: &#39;&lt;div&gt;baz&lt;/div&gt;&#39; }

&lt;!--没有名字的router-view默认为default--&gt;
&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;

const router = new VueRouter({
  routes: [
    {
      path: &#39;/&#39;,
      components: {
        default: Foo,
        a: Bar,
        b: Baz
      }
    }
  ]
})
</code></pre>

<h2 id="toc_10">重定向</h2>

<pre><code class="language-javascript">const router = new VueRouter({
  routes: [
    { path: &#39;/a&#39;, redirect: &#39;/b&#39; },
    { path: &#39;/c&#39;, redirect: { name: &#39;foo&#39; }},
    { path: &#39;/d&#39;, redirect: to =&gt; {
      // 方法接收 目标路由 作为参数
      // return 重定向的 字符串路径/路径对象
    }},
    
    // alias: url 保持 a 不变,路由匹配 b
    { path: &#39;/a&#39;, component: A, alias: &#39;/b&#39; }，
  ]
})
</code></pre>

<h2 id="toc_11">路由传参</h2>

<pre><code class="language-javascript"># 通过 props 解耦

const User = {
  props: [&#39;id&#39;],
  template: &#39;&lt;div&gt;User {{ id }}&lt;/div&gt;&#39;
}
const router = new VueRouter({
  routes: [
    { path: &#39;/user/:id&#39;, component: User, props: true },

    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：
    {
      path: &#39;/user/:id&#39;,
      components: { default: User, sidebar: Sidebar },
      props: { default: true, sidebar: false }
    }
  ]
})

这样你便可以在任何地方使用该组件，使得该组件更易于重用和测试。

# 布尔模式
如果 props 被设置为 true，route.params 将会被设置为组件属性。

# 对象模式
如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。

const router = new VueRouter({
  routes: [
    { path: &#39;/promotion/from-newsletter&#39;, component: Promotion, props: { newsletterPopup: false } }
  ]
})

# 函数模式

你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。

const router = new VueRouter({
  routes: [
    { path: &#39;/search&#39;, component: SearchUser, props: (route) =&gt; ({ query: route.query.q }) }
  ]
})

URL /search?q=vue 会将 {query: &#39;vue&#39;} 作为属性传递给 SearchUser 组件。
</code></pre>

<h2 id="toc_12">路由守卫</h2>

<p><code>全局守卫(router.beforeEach)</code></p>

<pre><code class="language-javascript">const router = new VueRouter({ ... })

router.beforeEach((to, from, next) =&gt; {
  // ...
})
每个守卫方法接收三个参数：
to: Route: 即将要进入的目标 路由对象
from: Route: 当前导航正要离开的路由
next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。
  next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是  confirmed （确认的）。
  next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。
  next(&#39;/&#39;) 或者 next({ path: &#39;/&#39; }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: &#39;home&#39; 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。
  next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。
  确保要调用 next 方法，否则钩子就不会被 resolved。
</code></pre>

<p><code>全局解析守卫(router.beforeResolve)</code></p>

<p>全局前置守卫区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p>

<p><code>全局后置钩子(router.afterEach)</code></p>

<p>和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：</p>

<pre><code class="language-javascript">router.afterEach((to, from) =&gt; {
  // ...
})
</code></pre>

<h3 id="toc_13">路由独享的守卫(beforeEnter)</h3>

<pre><code class="language-javascript">const router = new VueRouter({
  routes: [
    {
      path: &#39;/foo&#39;,
      component: Foo,
      beforeEnter: (to, from, next) =&gt; {
        // ...
      }
    }
  ]
})
</code></pre>

<h3 id="toc_14">组件内的守卫</h3>

<ol>
<li>beforeRouteEnter</li>
<li>beforeRouteUpdate</li>
<li>beforeRouteLeave</li>
</ol>

<pre><code class="language-javascript">const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
     next(vm =&gt; {
        // 通过 `vm` 访问组件实例
      })
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
    const answer = window.confirm(&#39;Do you really want to leave? you have unsaved changes!&#39;)
      if (answer) next()
      else next(false)
  }
}
</code></pre>

<h3 id="toc_15">完整流程</h3>

<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li>
</ol>

<h2 id="toc_16">路由元信息</h2>

<pre><code class="language-javascript">// 配置 meta 字段
const router = new VueRouter({
  routes: [
    {
      path: &#39;/foo&#39;,
      component: Foo,
      children: [
        {
          path: &#39;bar&#39;,
          component: Bar,
          // a meta field
          meta: { requiresAuth: true }
        }
      ]
    }
  ]
})

// 检查元字段
router.beforeEach((to, from, next) =&gt; {
  if (to.matched.some(record =&gt; record.meta.requiresAuth)) {
    // this route requires auth, check if logged in
    // if not, redirect to login page.
    if (!auth.loggedIn()) {
      next({
        path: &#39;/login&#39;,
        query: { redirect: to.fullPath }
      })
    } else {
      next()
    }
  } else {
    next() // 确保一定要调用 next()
  }
})
</code></pre>

<h2 id="toc_17">过度效果</h2>

<pre><code class="language-javascript">
// 单个效果
const Foo = {
  template: `
    &lt;transition name=&quot;slide&quot;&gt;
      &lt;div class=&quot;foo&quot;&gt;...&lt;/div&gt;
    &lt;/transition&gt;
  `
}

// 动态过渡
// &lt;!-- 使用动态的 transition name --&gt;
&lt;transition :name=&quot;transitionName&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/transition&gt;
// 接着在父组件内
// watch $route 决定使用哪种过渡
watch: {
  &#39;$route&#39; (to, from) {
    const toDepth = to.path.split(&#39;/&#39;).length
    const fromDepth = from.path.split(&#39;/&#39;).length
    this.transitionName = toDepth &lt; fromDepth ? &#39;slide-right&#39; : &#39;slide-left&#39;
  }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vue + typescript 采坑]]></title>
    <link href="http://rockwong.com/15338023812734.html"/>
    <updated>2018-08-09T16:13:01+08:00</updated>
    <id>http://rockwong.com/15338023812734.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>参考： <a href="https://juejin.im/post/5b54886ce51d45198f5c75d7">https://juejin.im/post/5b54886ce51d45198f5c75d7</a></p>
</blockquote>

<h2 id="toc_0">require.context 报错</h2>

<p><code>Property &#39;context&#39; does not exist on type &#39;NodeRequire&#39;.</code></p>

<pre><code class="language-bash"># 安装ts types
npm install --save-dev @types/webpack-env
</code></pre>

<p>tsconfig.json 配置</p>

<pre><code class="language-javascript">{
  &quot;compilerOptions&quot;: {
      &quot;types&quot;: [&quot;node&quot;, &quot;webpack-env&quot;]
      }
  }
</code></pre>

<p><code>webpack_require__(...).context is not a function</code> </p>

<p>检查参数错误，<code>context</code>的参数必须为字面量</p>

<h2 id="toc_1">import alias</h2>

<p><code>tsconfig.json</code> 和 <code>webpack</code> 中的 <code>alias</code>都需要设置，否则会出现部分问题，<br/>
 <code>webstorm</code>中右键 <code>src</code>目录 Mark directory as Resource root,解决编辑器识别路径的问题。</p>

<ul>
<li>解决 <code>webstorm</code>  import 时的路径自动完成，并根据项目目录文件自动提示</li>
<li>解决<code>typescript</code>报引用路径错误问题</li>
<li>解决编译报错问题 <code>compile with errors: This dependency was not found</code></li>
<li>点击 <code>improt</code> 方法自动打开文件定位到其位置,方便调试</li>
<li>在项目路径嵌套过深下引入 <code>src/services</code> 中的文件非常方便，省去冗余的相对路径&#39;../../../&#39;</li>
</ul>

<pre><code class="language-javascript">// 在根目录中的 vue.config.js
var path = require(&quot;path&quot;);

module.exports = {
  configureWebpack: {
    resolve: {
      alias: {
        services: path.resolve(__dirname, &quot;src/services&quot;)
      }
    }
  }
};
</code></pre>

<p><code>tsconfig.json</code> 中的路径配置</p>

<pre><code class="language-javascript">{
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: {
      &quot;services/*&quot;: [&quot;src/services/*&quot;],
      &quot;@/*&quot;: [&quot;src/*&quot;]
    }
  }
}

</code></pre>

<h2 id="toc_2">vuex</h2>

<ol>
<li>添加<code>modules</code>时开启 <code>namespaced=true</code></li>
<li>利用<code>vuex-class</code> 里用 namespace 修饰器 快捷访问vuex 中的modues 状态</li>
</ol>

<pre><code class="language-javascript">import { Component, Vue } from &quot;vue-property-decorator&quot;;
import { namespace } from &quot;vuex-class&quot;;
@Component
const about = namespace(&quot;about&quot;);
export default class Home extends Vue {
  @about.State
  message: string;
}
</code></pre>

<h2 id="toc_3">vue-class-component</h2>

<p><code>不要使用箭头函数方法访问 this ,无法正常工作</code></p>

<p>react 中有插件绑定this,所以正常工作，vue中目前不行</p>

<pre><code class="language-javascript">@Component
class MyComp extends Vue {
  foo = 123

  bar = () =&gt; {
    // Does not update the expected property.
    // `this` value is not a Vue instance in fact.
    this.foo = 456
  }
}
</code></pre>

<p><code>undefined</code> 不响应数据变化</p>

<pre><code class="language-javascript">@Component
class MyComp extends Vue {
  // Will not be reactive
  foo = undefined

  // Will be reactive
  bar = null

  data () {
    return {
      // Will be reactive
      baz: undefined
    }
  }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jsmpeg - 手机端视频处理方案]]></title>
    <link href="http://rockwong.com/15336095528357.html"/>
    <updated>2018-08-07T10:39:12+08:00</updated>
    <id>http://rockwong.com/15336095528357.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>github: <a href="https://github.com/phoboslab/jsmpeg">https://github.com/phoboslab/jsmpeg</a></p>
</blockquote>

<h2 id="toc_0">使用示例</h2>

<pre><code class="language-javascript">    &lt;canvas id=&quot;video-canvas&quot;&gt;&lt;/canvas&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;jsmpeg.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var canvas = document.getElementById(&#39;video-canvas&#39;);
        var url = &#39;ws://&#39;+document.location.hostname+&#39;:8082/&#39;;
        var player = new JSMpeg.Player(url, {canvas: canvas});
          player.audioOut.unlock();  // 解决ios等声音无法播放的问题
          player.play();
    &lt;/script&gt;
</code></pre>

<p>or</p>

<pre><code class="language-javascript">&lt;script src=&quot;jsmpeg.min.js&quot;&gt;&lt;/script&gt;
&lt;div class=&quot;jsmpeg&quot; data-url=&quot;video.ts&quot; data-loop=&quot;true&quot; data-autoplay=&quot;true&quot;&gt;&lt;/div&gt;
</code></pre>

<h2 id="toc_1">使用 FFMPEG 视频编码转换</h2>

<p><code>Homebrew</code>安装 FFmpeg​</p>

<pre><code class="language-bash"># 安装
brew install ffmpeg

# 更新
brew update &amp;&amp; brew upgrade ffmpeg

# 推荐安装的库
brew install ffmpeg --with-fdk-aac --with-ffplay --with-freetype --with-libass --with-libquvi --with-libvorbis --with-libvpx --with-opus --with-x265
</code></pre>

<h2 id="toc_2">转换编码参数</h2>

<pre><code class="language-bash">ffmpeg -i in.mp4 -f mpegts -codec:v mpeg1video -codec:a mp2 -b 0 out.ts
</code></pre>

<p>You can also control the video<br/>
 size (-s), <br/>
 framerate (-r), <br/>
 video bitrate (-b:v),<br/>
  audio bitrate (-b:a),<br/>
   number of audio channels (-ac), <br/>
   sampling rate (-ar) <br/>
   and much more. Please refer to the ffmpeg documentation for the details.</p>

<pre><code class="language-bash">ffmpeg -i in.mp4 -f mpegts \
    -codec:v mpeg1video -s 960x540 -b:v 1500k -r 30 -bf 0 \
    -codec:a mp2 -ar 44100 -ac 1 -b:a 128k \
    out.ts
</code></pre>

<h2 id="toc_3">Performance Considerations</h2>

<p>While JSMpeg can handle 720p video at 30fps even on an iPhone 5S, keep in mind that MPEG1 is not as efficient as modern codecs. MPEG1 needs quite a bit of bandwidth for HD video. 720p begins to look okay-ish at 2 Mbits/s (that&#39;s 250kb/s). Also, the higher the bitrate, the more work JavaScript has to do to decode it.</p>

<p>This should not be a problem for static files, or if you&#39;re only streaming within your local WiFi. If you don&#39;t need to support mobile devices, 1080p at 10mbit/s works just fine (if your encoder can keep up). For everything else I would advise you to use 540p (960x540) at 2Mbit/s max.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型的合并]]></title>
    <link href="http://rockwong.com/15333797108871.html"/>
    <updated>2018-08-04T18:48:30+08:00</updated>
    <id>http://rockwong.com/15333797108871.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">声明创建的实体</h2>

<table>
<thead>
<tr>
<th>Declaration</th>
<th>Namespace</th>
<th>Type</th>
<th>Value</th>
</tr>
</thead>

<tbody>
<tr>
<td>Namespace</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>Class</td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Enum</td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Interface</td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Type Alias</td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Function</td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>Variable</td>
<td></td>
<td></td>
<td>X</td>
</tr>
</tbody>
</table>

<h2 id="toc_1">接口合并</h2>

<ol>
<li>非函数声明应该是唯一，如果不唯一类型必须相同</li>
<li>双方成员合会并到同名的接口中</li>
<li>函数接口之间的顺序是后来的接口重载出现在靠前的位置</li>
<li>函数签名里有一个参数的类型是 单一的字符串字面量则会提升至顶端</li>
</ol>

<pre><code class="language-ts">interface Box {
    height: number;
    width: number;
}
interface Box {
    scale: number;
}

let box: Box = {height: 5, width: 6, scale: 10};
</code></pre>

<pre><code class="language-ts">interface Cloner {
    clone(animal: Animal): Animal;
}
interface Cloner {
    clone(animal: Sheep): Sheep;
}
interface Cloner {
    clone(animal: Dog): Dog;
    clone(animal: Cat): Cat;
}

// 三个接口合并成一个声明
interface Cloner {
    clone(animal: Dog): Dog;
    clone(animal: Cat): Cat;
    clone(animal: Sheep): Sheep;
    clone(animal: Animal): Animal;
}

</code></pre>

<pre><code class="language-ts">interface Document {
    createElement(tagName: any): Element;
}
interface Document {
    createElement(tagName: &quot;div&quot;): HTMLDivElement;
    createElement(tagName: &quot;span&quot;): HTMLSpanElement;
}
interface Document {
    createElement(tagName: string): HTMLElement;
    createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement;
}

// 合并后的顺序
interface Document {
    createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement;
    createElement(tagName: &quot;div&quot;): HTMLDivElement;
    createElement(tagName: &quot;span&quot;): HTMLSpanElement;
    createElement(tagName: string): HTMLElement;
    createElement(tagName: any): Element;
}
</code></pre>

<h2 id="toc_2">合并命名空间</h2>

<ol>
<li>模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口</li>
<li>重名的命名空间会被添加已存在的模块中</li>
</ol>

<pre><code class="language-ts">namespace Animals {
    export class Zebra { }
    let haveMuscles = true;
    export function animalsHaveMuscles() {
        return haveMuscles;
    }
}
namespace Animals {
    export interface Legged { numberOfLegs: number; }
    export class Dog { }
}

// 合并后
namespace Animals {
    export interface Legged { numberOfLegs: number; }

    export class Zebra { }
    export class Dog { }
    
    export function doAnimalsHaveMuscles() {
        return haveMuscles;  // &lt;-- error, haveMuscles is not visible here
    }
}

</code></pre>

<h2 id="toc_3">命名空间与类的合并</h2>

<p>如例：合并结果是一个类并带有一个内部类<code>AlbumLabel</code>。 你也可以使用命名空间为类增加一些静态属性</p>

<pre><code class="language-ts">class Album {
    label: Album.AlbumLabel;
}
namespace Album {
    export class AlbumLabel { }
}
</code></pre>

<h2 id="toc_4">命名空间与函数的合并</h2>

<p>合并后扩展它增加了一些属性</p>

<pre><code class="language-ts">function buildLabel(name: string): string {
    return buildLabel.prefix + name + buildLabel.suffix;
}

namespace buildLabel {
    export let suffix = &quot;&quot;;
    export let prefix = &quot;Hello, &quot;;
}

alert(buildLabel(&quot;Sam Smith&quot;));
</code></pre>

<h2 id="toc_5">命名空间与枚举的合并</h2>

<p>相似的，命名空间可以用来扩展枚举型：</p>

<pre><code class="language-ts">enum Color {
    red = 1,
    green = 2,
    blue = 4
}

namespace Color {
    export function mixColor(colorName: string) {
        if (colorName == &quot;yellow&quot;) {
            return Color.red + Color.green;
        }
        else if (colorName == &quot;white&quot;) {
            return Color.red + Color.green + Color.blue;
        }
        else if (colorName == &quot;magenta&quot;) {
            return Color.red + Color.blue;
        }
        else if (colorName == &quot;cyan&quot;) {
            return Color.green + Color.blue;
        }
    }
}
</code></pre>

<h2 id="toc_6">模块扩展</h2>

<p>如例：编译器对 <code>Observable.prototype.map</code>一无所知。 你可以使用扩展模块来将它告诉编译器.</p>

<pre><code class="language-ts">// observable.ts stays the same
// map.ts
import { Observable } from &quot;./observable&quot;;
declare module &quot;./observable&quot; {
    interface Observable&lt;T&gt; {
        map&lt;U&gt;(f: (x: T) =&gt; U): Observable&lt;U&gt;;
    }
}
Observable.prototype.map = function (f) {
    // ... another exercise for the reader
}


// consumer.ts
import { Observable } from &quot;./observable&quot;;
import &quot;./map&quot;;
let o: Observable&lt;number&gt;;
o.map(x =&gt; x.toFixed());
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[脚手架工具 vue-cli]]></title>
    <link href="http://rockwong.com/15332898454024.html"/>
    <updated>2018-08-03T17:50:45+08:00</updated>
    <id>http://rockwong.com/15332898454024.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">参数说明</h2>

<p>一. 功能选择</p>

<p>◉ <code>Babel</code>  js 低版本语言转换，建议勾选<br/><br/>
 ◉ <code>TypeScript</code> Ts 支持，根据需要勾选<br/>
 ◉ <code>Progressive Web App (PWA) Support</code> 利用 Service Worker 提升用户体验<br/>
 ◉ <code>Router</code> vue 官方路由，用作页面跳转<br/>
 ◉ <code>Vuex</code> 数据管理，类似Redux<br/>
 ◉ <code>CSS Pre-processors</code> scss postcss的支持<br/>
 ◉ <code>Linter / Formatter</code> 使用代码格式规范<br/>
 ◯ <code>Unit Testing</code> 测试方法<br/>
 ◉ <code>E2E Testing</code> 测试方法</p>

<p>二.  class-style component 以 class的方式写 vue的组件</p>

<ol>
<li><code>methods</code>，钩子都可以直接写作<code>class</code>的方法</li>
<li><code>computed</code>属性可以直接通过<code>get</code>来获得</li>
<li>初始化<code>data</code>可以声明为<code>class</code>的属性</li>
<li>其他的都可以放到<code>Component</code>装饰器里</li>
</ol>

<pre><code class="language-ts">import Vue from &#39;vue&#39;
import Component from &#39;vue-class-component&#39;

// @Component 修饰符注明了此类为一个 Vue 组件
@Component({
  // 所有的组件选项都可以放在这里
  template: &#39;&lt;button @click=&quot;onClick&quot;&gt;Click!&lt;/button&gt;&#39;
})
export default class MyComponent extends Vue {
  // 初始数据可以直接声明为实例的属性
  message: string = &#39;Hello!&#39;

  // 组件方法也可以直接声明为实例的方法
  onClick (): void {
    window.alert(this.message)
  }
}
</code></pre>

<p>三 . Use Babel alongside TypeScript for auto-detected polyfills? -&gt; 是否用babel做转义</p>

<p>四. Use history mode for router -&gt; 路由是否用 <code>history</code> 模式，或者 <code>hash</code> 模式。</p>

<p>五. Pick a CSS pre-processor  -&gt;  css 的预编译选择 <code>scss/sass</code></p>

<p>六. 格式化语言选择 <code>ESLint + Prettier</code></p>

<p>七. 选择 <code>E2E testing solution</code> -&gt; 选择测试方案 <code>Nightwatch (Selenium-based)</code> vue 测试框架</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEI 接口使用]]></title>
    <link href="http://rockwong.com/15332640241622.html"/>
    <updated>2018-08-03T10:40:24+08:00</updated>
    <id>http://rockwong.com/15332640241622.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">开始</h2>

<pre><code class="language-bash"># 安装
npm install nei –g

# 更新
npm update nei -g
</code></pre>

<h2 id="toc_1">指令</h2>

<pre><code class="language-bash">nei [指令] [参数]
</code></pre>

<p>其中可用的指令包括：</p>

<table>
<thead>
<tr>
<th style="text-align: left">指令</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">build</td>
<td style="text-align: left">根据在 NEI 平台上定义的工程规范，生成工程的初始化目录结构</td>
</tr>
<tr>
<td style="text-align: left">update</td>
<td style="text-align: left">更新通过 <code>nei build</code> 构建的项目</td>
</tr>
<tr>
<td style="text-align: left">server</td>
<td style="text-align: left">启动本地模拟容器</td>
</tr>
<tr>
<td style="text-align: left">template</td>
<td style="text-align: left">使用本地数据解析模板</td>
</tr>
</tbody>
</table>

<h3 id="toc_2">build</h3>

<pre><code class="language-bash">nei build -k [key] [参数]
</code></pre>

<table>
<thead>
<tr>
<th style="text-align: left">简写</th>
<th style="text-align: left">全称</th>
<th style="text-align: left">默认值</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-h</td>
<td style="text-align: left">--help</td>
<td style="text-align: left"></td>
<td style="text-align: left">显示 build 命令的帮助信息</td>
</tr>
<tr>
<td style="text-align: left">-o</td>
<td style="text-align: left">--output</td>
<td style="text-align: left">./</td>
<td style="text-align: left">指定项目的输出目录</td>
</tr>
<tr>
<td style="text-align: left">-k</td>
<td style="text-align: left">--key</td>
<td style="text-align: left"></td>
<td style="text-align: left">项目的唯一标识，可以在项目的&quot;工具(设置)&quot;中查看</td>
</tr>
<tr>
<td style="text-align: left">-sk</td>
<td style="text-align: left">--specKey</td>
<td style="text-align: left"></td>
<td style="text-align: left">规范的唯一标识，可以在规范的&quot;规范设置&quot;中查看</td>
</tr>
<tr>
<td style="text-align: left">-w</td>
<td style="text-align: left">--overwrite</td>
<td style="text-align: left">false</td>
<td style="text-align: left">是否覆盖已存在的文件，需要下载的文件不在此列，如果需要重新下载，请先将本地的文件删除</td>
</tr>
<tr>
<td style="text-align: left">无</td>
<td style="text-align: left">--specType</td>
<td style="text-align: left">web</td>
<td style="text-align: left">要构建的规范类型，目前支持 web、aos、ios、test 四种类型</td>
</tr>
</tbody>
</table>

<h3 id="toc_3">update</h3>

<pre><code class="language-bash">nei update [参数] 

nei update -w true  # 更新并覆盖当前文件

nei update -w true -develop true # 更新并覆盖当前文件,在args字段中增加 develop字段，值为true
</code></pre>

<p><code>nei update</code> 指令可用的参数包括：</p>

<table>
<thead>
<tr>
<th style="text-align: left">简写</th>
<th style="text-align: left">全称</th>
<th style="text-align: left">默认值</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-h</td>
<td style="text-align: left">--help</td>
<td style="text-align: left"></td>
<td style="text-align: left">显示 update 命令的帮助信息</td>
</tr>
<tr>
<td style="text-align: left">-o</td>
<td style="text-align: left">--output</td>
<td style="text-align: left">./</td>
<td style="text-align: left">指定的项目目录</td>
</tr>
<tr>
<td style="text-align: left">-k</td>
<td style="text-align: left">--key</td>
<td style="text-align: left"></td>
<td style="text-align: left">需要更新的项目的唯一标识</td>
</tr>
<tr>
<td style="text-align: left">-a</td>
<td style="text-align: left">--all</td>
<td style="text-align: left">false</td>
<td style="text-align: left">是否更新指定目录下面的所有项目，前提是没有指定的 key</td>
</tr>
<tr>
<td style="text-align: left">-w</td>
<td style="text-align: left">--overwrite</td>
<td style="text-align: left">false</td>
<td style="text-align: left">是否覆盖已存在的文件，需要下载的文件不在此列，如果需要重新下载，请先将本地的文件删除</td>
</tr>
<tr>
<td style="text-align: left">无</td>
<td style="text-align: left">--spec</td>
<td style="text-align: left">false</td>
<td style="text-align: left">是否更新规范中的普通文件和文件夹，以数据填充的文件不在此列</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型的兼容性]]></title>
    <link href="http://rockwong.com/15331829019400.html"/>
    <updated>2018-08-02T12:08:21+08:00</updated>
    <id>http://rockwong.com/15331829019400.html</id>
    <content type="html"><![CDATA[
<p>各种类型系统之间的兼容性</p>

<h2 id="toc_0">结构化类型</h2>

<p>如果<code>x</code>要兼容<code>y</code>，那么<code>y</code>至少具有与<code>x</code>相同的属性</p>

<pre><code class="language-ts">interface Named {
    name: string;
}

let x: Named;
// y&#39;s inferred type is { name: string; location: string; }
let y = { name: &#39;Alice&#39;, location: &#39;Seattle&#39; };
x = y;
</code></pre>

<h2 id="toc_1">比较函数</h2>

<p>一 .  <code>比较参数类型</code> 目标函数 <code>x</code>的每个参数必须能在<code>y</code>里找到对应类型的参数</p>

<pre><code class="language-ts">let x = (a: number) =&gt; 0;
let y = (b: number, s: string) =&gt; 0;

y = x; // OK
x = y; // Error
</code></pre>

<p>二 . <code>比较返回值类型</code> 目标函数 <code>x</code>的返回值必须是<code>y</code>返回值的父类</p>

<pre><code class="language-ts">let x = () =&gt; ({name: &#39;Alice&#39;});
let y = () =&gt; ({name: &#39;Alice&#39;, location: &#39;Seattle&#39;});

x = y; // OK
y = x; // Error because x() lacks a location property
</code></pre>

<h2 id="toc_2">枚举</h2>

<p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。</p>

<pre><code class="language-ts">enum Status { Ready, Waiting };
enum Color { Red, Blue, Green };

let status = Status.Ready;
status = Color.Green;  //error
</code></pre>

<h2 id="toc_3">类</h2>

<p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p>

<pre><code class="language-ts">class Animal {
    feet: number;
    constructor(name: string, numFeet: number) { }
}
class Size {
    feet: number;
    constructor(numFeet: number) { }
}
let a: Animal;
let s: Size;

a = s;  //OK
s = a;  //OK
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[泛型]]></title>
    <link href="http://rockwong.com/15331745903762.html"/>
    <updated>2018-08-02T09:49:50+08:00</updated>
    <id>http://rockwong.com/15331745903762.html</id>
    <content type="html"><![CDATA[
<p>泛型是一种特殊的变量，只用于表示类型而不是值</p>

<h2 id="toc_0">泛型函数</h2>

<p>类型参数<code>T</code>(可定义为任意变量名)在函数参数的前面</p>

<pre><code class="language-ts">function identity&lt;T&gt;(arg:T):T {
  return arg;
}
let output = identity&lt;string&gt;(&quot;myString&quot;)

let myIdentity:&lt;T&gt;(arg:T) =&gt; T = identity
let myIdentity1:{ &lt;T&gt;(arg:T):T} = identity
</code></pre>

<h2 id="toc_1">泛型接口</h2>

<pre><code class="language-ts">interface GenericIdentityFn {
  &lt;T&gt;(arg:T):T
}
function identity&lt;T&gt;(arg:T):T {
  return arg
}
let myIdentity:GenericIdentityFn = identity
</code></pre>

<h2 id="toc_2">泛型类</h2>

<p>泛型类看上去与泛型接口差不多。 泛型类使用（<code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p>

<pre><code class="language-ts">class GenericNumber&lt;T&gt; {
    zeroValue: T;
    add: (x: T, y: T) =&gt; T;
}

let myGenericNumber = new GenericNumber&lt;number&gt;();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
</code></pre>

<p>类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型(因为实例中不继承静态属性)。</p>

<h2 id="toc_3">泛型约束</h2>

<p><code>extends</code> 继承了一个接口进而对<code>泛型的数据结构</code>进行了限制</p>

<pre><code class="language-ts">// 限制函数去处理任意带有.length属性的所有类型
interface Lengthwise {
  length:number
}
function loggingIdentity&lt;T extends Lengthwise&gt;(arg:T):T {
  console.log(arg.length)
  return arg
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类]]></title>
    <link href="http://rockwong.com/15331136386590.html"/>
    <updated>2018-08-01T16:53:58+08:00</updated>
    <id>http://rockwong.com/15331136386590.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15331136386590/15331136529051.jpg" alt=""/></p>

<h2 id="toc_0">类的修饰器</h2>

<p><code>public</code> 在 TypeScript 中，成员属性默认为 public</p>

<p><code>private</code> 不能声明它的外部访问</p>

<p><code>protected</code> 与 <code>private</code>类似，但在继承类中仍然可以访问</p>

<p><code>readonly</code> 关键字将属性设置为只读，只读属性必须在声明或者构造函数里被初始化</p>

<h2 id="toc_1">存取器</h2>

<p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问.</p>

<p>如果访问对象只设置 <code>getters</code>，没有设置<code>setters</code>则认为该属性为只读。</p>

<pre><code class="language-ts">let passcode = &#39;secret passcode&#39;
class Employee {
  private _fullName:string;
  get fullName():string {
    return this._fullName
  }
  set fullName(newName:string){
    if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) {
      this._fullName = newName
    } else {
      console.log(&quot;Error: Unauthorized update of employee!&quot;);
    }
  }
}
let employee = new Employee();
employee.fullName = &quot;Bob Smith&quot;;
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>

<h2 id="toc_2">抽象类</h2>

<p>派生类的基类使用，不会能直接被实例化<br/>
抽象类中的<code>抽象方法</code>不包含具体实现并且必须在派生类中实现<br/>
抽象类和可包含成员的实现细节，必须包含 <code>abstract</code> 关键字标识和访问修饰符</p>

<pre><code class="language-ts">abstract class Department {
    constructor(public name: string) {}
    printName(): void {
        console.log(&#39;Department name: &#39; + this.name);
    }
    abstract printMeeting(): void; // 必须在派生类中实现
}

class AccountingDepartment extends Department {
    constructor() {
        super(&#39;Accounting and Auditing&#39;); // 在派生类的构造函数中必须调用 super()
    }
    printMeeting(): void {
        console.log(&#39;The Accounting Department meets each Monday at 10am.&#39;);
    }
    generateReports(): void {
        console.log(&#39;Generating accounting reports...&#39;);
    }
}

let department: Department; // 允许创建一个对抽象类型的引用
department = new Department(); // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
department.printName();
department.printMeeting();
department.generateReports(); // 错误: 方法在声明的抽象类中不存在
</code></pre>

<h2 id="toc_3">类可以当着类型接口使用</h2>

<p>类定义会创建两个东西：<code>类的实例</code>和 <code>一个构造函数</code>，类可以创建类型，所以你能够在允许使用接口的地方使用类</p>

<pre><code class="language-ts">class Point {
  x:number;
  y:number;
}
interface Point3d extends Point {
  z:number
}
let point3d:Point3d = {x:1,y:2,z:3}
</code></pre>

<h2 id="toc_4">内置对象</h2>

<p><code>JavaScript</code> 内置对象，直接在 <code>TypeScript</code> 中当做定义好了的类型</p>

<pre><code class="language-ts">let b:Boolean = new Boolean(1)
let c:Error = new Error(&#39;Error occurred&#39;)
let d:Date = new Date()
let r:RegExp = /[a-z]/
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[接口]]></title>
    <link href="http://rockwong.com/15331085326209.html"/>
    <updated>2018-08-01T15:28:52+08:00</updated>
    <id>http://rockwong.com/15331085326209.html</id>
    <content type="html"><![CDATA[
<p><code>TypeScript</code> 核心原则之一是对值所具有的结构进行类型检查，它是对行为的抽象，具体行动需要有类去实现，一般接口<strong>首字母大写</strong></p>

<pre><code class="language-ts">interface Point {
  x:number;
  color?:string;  // 可选属性
  readonly y:number;   // 只读属性
  [propName: string]: any; // 额外的可选属性
}
</code></pre>

<p><code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，确保数组创建后再也不能被修改<br/>
<code>readonly</code> vs <code>const</code> : 属性用 <code>readonly</code> 变量用 <code>const</code></p>

<h2 id="toc_0">通过额外的属性检查</h2>

<p>1.可以使用类型断言绕过这些检查</p>

<pre><code class="language-ts">let strLength:number = (&lt;string&gt;someValue).length   //“尖括号”语法
let strLength1: number = (someValue as string).length    //一个为 `as` 语法

</code></pre>

<p>2.使用索引签，对象赋值给另一个变量，对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候</p>

<pre><code class="language-ts">let squareOptions = { colour: &quot;red&quot;, width: 100 }
let mySquare = createSquare(squareOptions)
</code></pre>

<p>3.添加字符串索引签名</p>

<pre><code class="language-text">interface SquareConfig {
  color?:string;
  width?:number;
  [propName:string]:any; // 额外的属性检查
}
</code></pre>

<h2 id="toc_1">接口描述函数类型</h2>

<pre><code class="language-ts">interface SearchFunc {
  (source:string,subString:string):boolean;
}
let MySearch:SearchFunc;
MySearch = function(source:string,subString:string) {
  let result = source.search(subString);
  return result &gt; -1
}
</code></pre>

<h2 id="toc_2">可索引的类型</h2>

<pre><code class="language-ts">interface StringArray {
  [index:number]:string // 定义数组索引
}
let myArray:StringArray = [&quot;Bob&quot;,&#39;Fred&#39;]

// 索引匹配
interface NumberDictionary {
  [index: string]: number; //定义索引匹配
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}

// 索引只读
interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = [&quot;Alice&quot;, &quot;Bob&quot;];
myArray[2] = &quot;Mallory&quot;; // error! 索引签名是只读的
</code></pre>

<h2 id="toc_3">类类型</h2>

<p>使用关键字 <code>implements</code> </p>

<pre><code class="language-ts">interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
</code></pre>

<h2 id="toc_4">继承接口</h2>

<p>关键字<code>extends</code></p>

<pre><code class="language-ts">interface Shape {
  color:string;
}
interface PenStroke {
  penWidth:number;
}
interface Square extends Shape,PenStroke {
  sideLength:number
}
let square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
square.penWidth = 5.0;
</code></pre>

<p><code>extends</code> 是继承某个类, 继承之后可以使用父类的方法, 也可以重写父类的方法;</p>

<p><code>implements</code> 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用</p>

]]></content>
  </entry>
  
</feed>
