{"data":{"markdownRemark":{"html":"<h1>dva 教程</h1>\n<h2>结构划分</h2>\n<p>dva 架构的项目中，目录基本结构为：</p>\n<pre><code class=\"language-bash\">.\n├── /mock/           # 数据mock的接口文件\n├── /src/            # 项目源码目录\n│ ├── /components/   # 项目组件\n│ ├── /routes/       # 路由组件（页面维度）\n│ ├── /models/       # 数据模型\n│ ├── /services/     # 数据接口\n│ ├── /utils/        # 工具函数\n│ ├── route.js       # 路由配置\n│ ├── index.js       # 入口文件\n│ ├── index.less     \n│ └── index.html     \n├── package.json     # 项目信息\n└── proxy.config.js  # 数据mock配置\n</code></pre>\n<h2>设计 Model</h2>\n<h3>Model 的设计</h3>\n<p>在抽离了<code>users</code>以后，我们来看下如何设计，通常有以下两种方式：</p>\n<ol>\n<li>按照数据维度</li>\n<li>按照业务维度</li>\n</ol>\n<h4>数据维度</h4>\n<p>按照数据维度的 model 设计原则就是抽离数据本身以及相关操作的方法，比如 <code>users</code> ：</p>\n<pre><code class=\"language-javascript\">// models/users.js\n\nexport default {\n  namespace: 'users',\n  state: {\n    list: [],\n    total: null,\n  },\n    effects: {\n        *query(){},\n        *create(){},\n        // 因为delete是关键字\n        *'delete'(){},\n        *update(){},\n    },\n    reducers: {\n        querySuccess(){},\n        createSuccess(){},\n        deleteSuccess(){},\n        updateSuccess(){},\n    }\n}\n</code></pre>\n<p>如果你写过后台代码，你会发现这跟我们常常写的后台接口是很类似的，只关心数据本身，至于在使用 <code>users</code> model 的组件中所遇到的状态管理等信息跟 model 无关，而是作为组件自身的state维护。</p>\n<p>这种设计方式使得 model 很纯粹，在设计通用数据信息 model 的时候比较适用，比如当前用户登陆信息等数据 model。但是在数据跟业务状态交互比较紧密，数据不是那么独立的时候会有些不那么方便，因为在数据跟业务状态紧密相连的场景下，将状态放到 model 里面维护会使得我们的代码更加清晰可控，而这种方式就是下面将要介绍的 <code>业务维度</code> 方式的设计。</p>\n<h4>业务维度</h4>\n<p>按照业务维度的 model 设计，则是将数据以及使用强关联数据的组件中的状态统一抽象成 model 的方法，在本例中，<code>users</code> model设计如下：</p>\n<pre><code class=\"language-javascript\">// models/users.js\n\nexport default {\n  namespace: 'users',\n\n  state: {\n    list: [],\n    total: null, \n    loading: false, // 控制加载状态\n    current: null, // 当前分页信息\n    currentItem: {}, // 当前操作的用户对象\n    modalVisible: false, // 弹出窗的显示状态\n    modalType: 'create', // 弹出窗的类型（添加用户，编辑用户）\n  },\n    effects: {\n        *query(){},\n        *create(){},\n        *'delete'(){},\n        *update(){},\n    },\n    reducers: {\n        showLoading(){}, // 控制加载状态的 reducer\n        showModal(){}, // 控制 Modal 显示状态的 reducer\n        hideModal(){},\n        querySuccess(){},\n        createSuccess(){},\n        deleteSuccess(){},\n        updateSuccess(){},\n    }\n}\n</code></pre>\n<h2>组件设计</h2>\n<p>React 应用是由一个个独立的 Component 组成的，我们在拆分 Component 的过程中要尽量让每个 Component 专注做自己的事。</p>\n<p>一般来说，我们的组件有两种设计：</p>\n<ol>\n<li>Container Component</li>\n<li>Presentational Component</li>\n</ol>\n<h4>Container Component</h4>\n<p>Container Component 一般指的是具有<code>监听数据行为</code>的组件，一般来说它们的职责是<code>绑定相关联的 model 数据</code>，以数据容器的角色包含其它子组件，通常在项目中表现出来的类型为：Layouts、Router Components 以及普通 Containers 组件。</p>\n<p>通常的书写形式为：</p>\n<pre><code class=\"language-javascript\">import React, { Component, PropTypes } from 'react';\n\n// dva 的 connect 方法可以将组件和数据关联在一起\nimport { connect } from 'dva';\n\n// 组件本身\nconst MyComponent = (props)=>{};\nMyComponent.propTypes = {};\n\n// 监听属性，建立组件和数据的映射关系\nfunction mapStateToProps(state) {\n  return {...state.data};\n}\n\n// 关联 model\nexport default connect(mapStateToProps)(MyComponent);\n</code></pre>\n<h4>Presentational Component</h4>\n<p>Presentational Component 的名称已经说明了它的职责，展示形组件，一般也称作：Dumb Component，它不会关联订阅 model 上的数据，而所需数据的传递则是通过 props 传递到组件内部。</p>\n<p>通常的书写形式：</p>\n<pre><code class=\"language-javascript\">import React, { Component, PropTypes } from 'react';\n\n// 组件本身\n// 所需要的数据通过 Container Component 通过 props 传递下来\nconst MyComponent = (props)=>{}\nMyComponent.propTypes = {};\n\n// 并不会监听数据\nexport default MyComponent;\n</code></pre>\n<h4>对比</h4>\n<p>对组件分类，主要有两个好处：</p>\n<ol>\n<li>让项目的数据处理更加集中；</li>\n<li>让组件高内聚低耦合，更加聚焦；</li>\n</ol>\n<p>试想如果每个组件都去订阅数据 model，那么一方面组件本身跟 model 耦合太多，另一方面代码过于零散，到处都在操作数据，会带来后期维护的烦恼。</p>","frontmatter":{"title":"dva 教程"}}},"pageContext":{"slug":"/notes/dva 教程/","tagPath":"/React/dva 教程/"}}