{"data":{"markdownRemark":{"html":"<h1>React Router</h1>\n<h2>基本用法</h2>\n<p><strong>安装</strong>\n<code>npm install -S react-router</code></p>\n<p>使用时,路由器<code>Router</code>就是React的一个组件</p>\n<pre><code class=\"language-js\">import { Router } from 'react-router';\nrender(&#x3C;Router/>, document.getElementById('app'));\n</code></pre>\n<p>真正的路由要通过<code>Route</code>组件定义。</p>\n<pre><code class=\"language-js\">import { Router, Route, hashHistory } from 'react-router';\n\nrender((\n  &#x3C;Router history={hashHistory}>\n    &#x3C;Route path=\"/\" component={App}/>\n  &#x3C;/Router>\n), document.getElementById('app'));\n</code></pre>\n<p>用户访问根路由<code>/</code> ,组件<code>app</code>就会加载到<code>document.getElementById('app')</code></p>\n<h2>嵌套路由</h2>\n<p><code>Route</code> 组件可以嵌套</p>\n<pre><code class=\"language-js\">&#x3C;Router history={hashHistory}>\n  &#x3C;Route path=\"/\" component={App}>\n    &#x3C;Route path=\"/repos\" component={Repos}/>\n    &#x3C;Route path=\"/about\" component={About}/>\n  &#x3C;/Route>\n&#x3C;/Router>\n</code></pre>\n<p>上面代码中，用户访问<code>/repos</code>时，会先加载<code>App</code>组件，然后在它的内部再加载<code>Repos</code>组件。</p>\n<p><code>App</code> 组件要写成下面样子</p>\n<pre><code class=\"language-js\">export default React.createClass({\n  render() {\n    return &#x3C;div>\n      {this.props.children}\n    &#x3C;/div>\n  }\n})\n</code></pre>\n<p>路由也可以不写在<code>Router</code>组件里面，单独传入<code>Router</code>组件的<code>routes</code>属性。</p>\n<pre><code class=\"language-js\">let routes = &#x3C;Route path=\"/\" component={App}>\n  &#x3C;Route path=\"/repos\" component={Repos}/>\n  &#x3C;Route path=\"/about\" component={About}/>\n&#x3C;/Route>;\n\n&#x3C;Router routes={routes} history={browserHistory}/>\n</code></pre>\n<pre><code class=\"language-js\">const routes = {\n  path: '/',\n  component: App,\n  indexRoute: { component: Home },\n  childRoutes: [\n    { path: 'about', component: About },\n    { path: 'inbox', component: Inbox },\n  ]\n}\n</code></pre>\n<h2>动态路由</h2>\n<pre><code class=\"language-js\">const CourseRoute = {\n  path: 'course/:courseId',\n\n  getChildRoutes(location, callback) {\n    require.ensure([], function (require) {\n      callback(null, [\n        require('./routes/Announcements'),\n        require('./routes/Assignments'),\n        require('./routes/Grades'),\n      ])\n    })\n  },\n\n  getIndexRoute(location, callback) {\n    require.ensure([], function (require) {\n      callback(null, require('./components/Index'))\n    })\n  },\n\n  getComponents(location, callback) {\n    require.ensure([], function (require) {\n      callback(null, require('./components/Course'))\n    })\n  }\n}\n</code></pre>\n<h2>path 属性</h2>\n<p><code>Route</code>组件的<code>path</code>属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。</p>\n<p><code>path</code>属性可以使用通配符。</p>\n<pre><code>（1）:paramName\n:paramName匹配URL的一个部分，直到遇到下一个/、?、#为止。这个路径参数可以通过this.props.params.paramName取出。\n（2）()\n()表示URL的这个部分是可选的。\n（3）*\n*匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。\n（4） **\n** 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式。\n</code></pre>\n<p><code>path</code>属性也可以使用相对路径（不以<code>/</code>开头），匹配时就会相对于父组件的路径,也可以使用绝对路由</p>\n<p>路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。</p>\n<pre><code class=\"language-js\">&#x3C;Route path=\"/comments\" ... />\n&#x3C;Route path=\"/comments\" ... />\n</code></pre>\n<p>上面代码中，路径/comments同时匹配两个规则，第二个规则不会生效。</p>\n<p><strong>设置路径参数时，需要特别小心这一点。</strong></p>\n<pre><code class=\"language-js\">&#x3C;Router>\n  &#x3C;Route path=\"/:userName/:id\" component={UserPage}/>\n  &#x3C;Route path=\"/about/me\" component={About}/>\n&#x3C;/Router>\n</code></pre>\n<p>上面代码中，用户访问<code>/about/me</code>时，不会触发第二个路由规则，因为它会匹配<code>/:userName/:id</code>这个规则。因此，带参数的路径一般要写在路由规则的底部。</p>\n<p><strong>query</strong>\nURL的查询字符串<code>/foo?bar=baz</code>，可以用<code>this.props.location.query.bar</code>获取。</p>\n<h2>IndexRoute 组件</h2>\n<p>如有没有<code>IndexRoute</code> 组件访问根路径<code>/</code>，不会加载任何子组件。也就是说，<code>App</code>组件的<code>this.props.children</code>，这时是<code>undefined</code>。</p>\n<p>加入<code>IndexRoute</code> 组件代码如下</p>\n<pre><code class=\"language-js\">&#x3C;Router>\n  &#x3C;Route path=\"/\" component={App}>\n    &#x3C;IndexRoute component={Home}/>\n    &#x3C;Route path=\"accounts\" component={Accounts}/>\n    &#x3C;Route path=\"statements\" component={Statements}/>\n  &#x3C;/Route>\n&#x3C;/Router>\n</code></pre>\n<p>现在，用户访问<code>/</code>的时候，加载的组件结构如下。</p>\n<pre><code class=\"language-js\">&#x3C;App>\n  &#x3C;Home/>\n&#x3C;/App>\n</code></pre>\n<p><code>IndexRoute</code>组件没有路径参数path</p>\n<h2>Redirect 组件</h2>\n<p><code>&#x3C;Redirect></code> 组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。</p>\n<pre><code class=\"language-js\">&#x3C;Route path=\"inbox\" component={Inbox}>\n  {/* 从 /inbox/messages/:id 跳转到 /messages/:id */}\n  ＜Redirect from=\"messages/:id\" to=\"/messages/:id\" />\n&#x3C;/Route>\n</code></pre>\n<p>现在访问<code>/inbox/messages/5</code>，会自动跳转到<code>/messages/5</code>。</p>\n<h2>IndexRedirect 组件</h2>\n<p><code>IndexRedirect</code>组件用于访问根路由的时候，将用户重定向到某个子组件。</p>\n<pre><code class=\"language-js\">&#x3C;Route path=\"/\" component={App}>\n  ＜IndexRedirect to=\"/welcome\" />\n  &#x3C;Route path=\"welcome\" component={Welcome} />\n  &#x3C;Route path=\"about\" component={About} />\n&#x3C;/Route>\n</code></pre>\n<p>上面代码中，用户访问根路径时，将自动重定向到子组件<code>welcome</code>。</p>\n<h2>Link</h2>\n<p><code>Link</code>组件用于取代<code>&#x3C;a></code>元素</p>\n<pre><code class=\"language-js\">render() {\n  return &#x3C;div>\n    &#x3C;ul role=\"nav\">\n      &#x3C;li>&#x3C;Link to=\"/about\">About&#x3C;/Link>&#x3C;/li>\n      &#x3C;li>&#x3C;Link to=\"/repos\">Repos&#x3C;/Link>&#x3C;/li>\n    &#x3C;/ul>\n  &#x3C;/div>\n</code></pre>\n<p>如果希望当前的路由与其他路由有不同样式，这时可以使用Link组件的<code>activeStyle</code>属性。</p>\n<pre><code class=\"language-js\">&#x3C;Link to=\"/about\" activeStyle={{color: 'red'}}>About&#x3C;/Link>\n&#x3C;Link to=\"/repos\" activeStyle={{color: 'red'}}>Repos&#x3C;/Link>\n</code></pre>\n<p>另一种做法是，使用<code>activeClassName</code>指定当前路由的<code>Class</code>。</p>\n<pre><code class=\"language-js\">&#x3C;Link to=\"/about\" activeClassName=\"active\">About&#x3C;/Link>\n&#x3C;Link to=\"/repos\" activeClassName=\"active\">Repos&#x3C;/Link>\n</code></pre>\n<p>在<code>Router</code>组件之外，导航到路由页面，可以使用浏览器的<code>History API</code>，像下面这样写。</p>\n<pre><code class=\"language-js\">import { browserHistory } from 'react-router';\nbrowserHistory.push('/some/path');\n</code></pre>\n<h2>IndexLink</h2>\n<p>如果链接到根路由<code>/</code>，不要使用<code>Link</code>组件，而要使用<code>IndexLink</code>组件。\n这是因为对于根路由来说，<code>activeStyle</code>和<code>activeClassName</code>会失效，或者说总是生效，因为/会匹配任何子路由。而<code>IndexLink</code>组件会使用路径的精确匹配。</p>\n<pre><code class=\"language-js\">IndexLink to=\"/\" activeClassName=\"active\">\n  Home\n&#x3C;/IndexLink>\n</code></pre>\n<p>另一种方法是使用<code>Link</code>组件的<code>onlyActiveOnIndex</code>属性，也能达到同样效果。</p>\n<pre><code class=\"language-js\">&#x3C;Link to=\"/\" activeClassName=\"active\" onlyActiveOnIndex={true}>\n  Home\n&#x3C;/Link>\n</code></pre>\n<p>实际上，<code>IndexLink</code>就是对<code>Link</code>组件的<code>onlyActiveOnIndex</code>属性的包装。</p>\n<h2>histroy 属性</h2>\n<p><code>Router</code>组件的<code>history</code>属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。</p>\n<p><code>history</code>属性一共可以设置三种值。</p>\n<ul>\n<li>browserHistory</li>\n<li>hashHistory</li>\n<li>createMemoryHistory</li>\n</ul>\n<p><strong>hashHistory</strong>\n路由将通过URL的hash部分（#）切换,URL的形式类似<code>example.com/#/some/path</code>。</p>\n<p><strong>browserHistory</strong>\n显示正常的路径例如: <code>example.com/some/path</code>，背后调用的是浏览器的History API</p>\n<pre><code class=\"language-js\">import { browserHistory } from 'react-router'\n\nrender(\n  &#x3C;Router history={browserHistory} routes={routes} />,\n  document.getElementById('app')\n)\n</code></pre>\n<p>但是，这种情况需要对服务器改造。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。\n如果开发服务器使用的是<code>webpack-dev-server</code>，加上<code>--history-api-fallback</code>参数就可以了。\n<code>$ webpack-dev-server --inline --content-base . --history-api-fallback</code></p>\n<p><strong>createMemoryHistory</strong>\n要用于服务器渲染。它创建一个内存中的history对象，不与浏览器URL互动。\n<code>const history = createMemoryHistory(location)</code></p>\n<h2>表单处理</h2>\n<p>表单跳转、点击按钮跳转等操作与React Router 对接。</p>\n<pre><code class=\"language-js\">&#x3C;form onSubmit={this.handleSubmit}>\n  &#x3C;input type=\"text\" placeholder=\"userName\"/>\n  &#x3C;input type=\"text\" placeholder=\"repo\"/>\n  &#x3C;button type=\"submit\">Go&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>第一种方法是使用<code>browserHistory.push</code></p>\n<pre><code class=\"language-js\">import { browserHistory } from 'react-router'\n\n// ...\n  handleSubmit(event) {\n    event.preventDefault()\n    const userName = event.target.elements[0].value\n    const repo = event.target.elements[1].value\n    const path = `/repos/${userName}/${repo}`\n    browserHistory.push(path)\n  },\n</code></pre>\n<p>第二种方法是使用<code>context</code>对象。</p>\n<pre><code class=\"language-js\">export default React.createClass({\n\n  // ask for `router` from context\n  contextTypes: {\n    router: React.PropTypes.object\n  },\n\n  handleSubmit(event) {\n    // ...\n    this.context.router.push(path)\n  },\n})\n</code></pre>\n<h2>路由的钩子</h2>\n<p>每个路由都有<code>Enter</code>和<code>Leave</code>钩子，用户进入或离开该路由时触发。</p>\n<pre><code class=\"language-js\">&#x3C;Route path=\"about\" component={About} />\n＜Route path=\"inbox\" component={Inbox}>\n  ＜Redirect from=\"messages/:id\" to=\"/messages/:id\" />\n&#x3C;/Route>\n</code></pre>\n<p>面的代码中，如果用户离开<code>/messages/:id</code>，进入<code>/about</code>时，会依次触发以下的钩子。</p>\n<ul>\n<li>/messages/:id的onLeave</li>\n<li>/inbox的onLeave</li>\n<li>/about的onEnter</li>\n</ul>\n<p>下面是一个例子，使用<code>onEnter</code>钩子替代<code>&#x3C;Redirect></code>组件。</p>\n<pre><code class=\"language-js\">&#x3C;Route path=\"inbox\" component={Inbox}>\n  &#x3C;Route\n    path=\"messages/:id\"\n    onEnter={\n      ({params}, replace) => replace(`/messages/${params.id}`)\n    } \n  />\n&#x3C;/Route>\n</code></pre>\n<p>当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。</p>\n<pre><code class=\"language-js\">const Home = withRouter(\n  React.createClass({\n    componentDidMount() {\n      this.props.router.setRouteLeaveHook(\n        this.props.route, \n        this.routerWillLeave\n      )\n    },\n\n    routerWillLeave(nextLocation) {\n      // 返回 false 会继续停留当前页面，\n      // 否则，返回一个字符串，会显示给用户，让其自己决定\n      if (!this.state.isSaved)\n        return '确认要离开？';\n    },\n  })\n)\n</code></pre>\n<p>上面代码中，<code>setRouteLeaveHook</code>方法为<code>Leave</code>钩子指定<code>routerWillLeave</code>函数。该方法如果返回<code>false</code>，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。</p>","frontmatter":{"title":"React Router"}}},"pageContext":{"slug":"/notes/React Router/","tagPath":"/React/React Router/"}}