{"data":{"markdownRemark":{"html":"<h1>GraphQl 查询和变更</h1>\n<h2>查询字段 和 参数</h2>\n<pre><code>{\n # 查询可以有参数\n  hero(id: \"1000\") {\n    name\n   \n    # 查询参数可以是：标量（scalar）\n    height(unit: FOOT)\n    friends {\n      name\n    }\n  }\n  \n  # 查询的字段名称可以重命名 \n  jediHero: hero(episode: JEDI) {\n    name\n  }\n}\n</code></pre>\n<h2>片段（Fragments）</h2>\n<p>正反派主角及其友军分为两拨，使用<code>fragment</code> 解决查询字段重复的问题。</p>\n<pre><code>{\n  leftComparison: hero(episode: EMPIRE) {\n    ...comparisonFields\n  }\n  rightComparison: hero(episode: JEDI) {\n    ...comparisonFields\n  }\n}\n\nfragment comparisonFields on Character {\n  name\n  appearsIn\n  friends {\n    name\n  }\n}\n</code></pre>\n<h2>操作名称（Operation name）</h2>\n<p>上述示例简写句法，省略了 query 关键字和查询名称。</p>\n<p>生产环境中使用好处：<code>减少代码歧义</code> <code>方便调试</code> <code>服务器端日志记录</code></p>\n<p>操作类型可以是：<code>query</code> <code>mutation</code> <code>subscription</code></p>\n<pre><code># 操作类型：query\n# 操作名称：HeroNameAndFriends\nquery HeroNameAndFriends {\n  hero {\n    name\n    friends {\n      name\n    }\n  }\n}\n</code></pre>\n<h2>变量（Variables）</h2>\n<p>变量名 <code>$episode</code>\n变量类型 <code>Episode</code>\n默认值 <code>JEDI</code></p>\n<p>声明的变量都必须是<code>标量</code>、<code>枚举型</code>或者<code>输入对象</code>类型\n如果想要传递一个复杂对象到一个字段上，你必须知道服务器上其匹配的类型</p>\n<pre><code>query HeroNameAndFriends($episode: Episode = \"JEDI\") {\n  hero(episode: $episode) {\n    name\n    friends {\n      name\n    }\n  }\n}\n\n# VARIABLES\n{\n  \"episode\": \"JEDI\"\n}\n</code></pre>\n<h2>指令（Directives）</h2>\n<p>用一个变量动态的改变查询结构，例如：概括视图和详情视图等功能。</p>\n<ul>\n<li><code>@include(if: Boolean)</code> 仅在参数为 <code>true</code> 时，包含此字段</li>\n<li><code>@skip(if: Boolean)</code> 如果参数为 <code>true</code>，跳过此字段。</li>\n</ul>\n<pre><code>query Hero($episode: Episode, $withFriends: Boolean!) {\n  hero(episode: $episode) {\n    name\n    friends @include(if: $withFriends) {\n      name\n    }\n  }\n}\n# VARIABLES\n{\n  \"episode\": \"JEDI\",\n  \"withFriends\": false\n}\n</code></pre>\n<h2>变更（Mutations）</h2>\n<p>约定来规范任何导致写入的操作都应该显式通过变更（mutation）来发送。</p>\n<pre><code>mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n  createReview(episode: $ep, review: $review) {\n    stars\n    commentary\n  }\n}\n# VARIABLES\n{\n  \"ep\": \"JEDI\",\n  \"review\": {\n    \"stars\": 5,\n    \"commentary\": \"This is a great movie!\"\n  }\n}\n</code></pre>\n<p>注意 <code>createReview</code> 字段如何返回了新建的 <code>review</code> 的 <code>stars</code> 和 <code>commentary</code> 字段。这在变更已有数据时特别有用，例如，当一个字段自增的时候，我们可以在一个请求中变更并查询这个字段的新值。</p>\n<h2>变更中的多个字段</h2>\n<p><strong>查询字段时，是并行执行，而变更字段时，是线性执行，一个接着一个。</strong></p>\n<h2>内联片段（Inline Fragments）</h2>\n<p>如果你查询的字段返回的是<code>接口</code>或者<code>联合类型</code>，那么你可能需要使用<code>内联片段</code>来取出下层具体类型的数据</p>\n<pre><code># query 变量$ep，类型Episode，！为必选\nquery HeroForEpisode($ep: Episode!) {\n\n  # 筛选参数：episode,值：$ep\n  hero(episode: $ep) {\n    name\n    \n    # episode类型为Droid，显示primaryFunction\n    ... on Droid {\n      primaryFunction\n    }\n    \n     # episode类型为Human，显示height\n    ... on Human {\n      height\n    }\n  }\n}\n</code></pre>\n<h2>元字段（Meta fields）</h2>\n<p>从GraphQL 服务获得类型，在查询的任何位置请求元字段 <code>__typename</code></p>\n<pre><code>{\n  search(text: \"an\") {\n    __typename\n    ... on Human {\n      name\n    }\n    ... on Droid {\n      name\n    }\n    ... on Starship {\n      name\n    }\n  }\n}\n\n## 结果\n\n{\n  \"data\": {\n    \"search\": [\n      {\n        \"__typename\": \"Human\",\n        \"name\": \"Han Solo\"\n      },\n      {\n        \"__typename\": \"Human\",\n        \"name\": \"Leia Organa\"\n      },\n      {\n        \"__typename\": \"Starship\",\n        \"name\": \"TIE Advanced x1\"\n      }\n    ]\n  }\n}\n</code></pre>","frontmatter":{"title":"GraphQl 查询和变更"}}},"pageContext":{"slug":"/notes/GraphQl 查询和变更/","tagPath":"/Gatsby/GraphQl 查询和变更/"}}