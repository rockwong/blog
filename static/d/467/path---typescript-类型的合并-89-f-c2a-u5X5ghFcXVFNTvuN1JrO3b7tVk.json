{"data":{"markdownRemark":{"html":"<h1>类型的合并</h1>\n<h2>声明创建的实体</h2>\n<table>\n<thead>\n<tr>\n<th>Declaration</th>\n<th>Namespace</th>\n<th>Type</th>\n<th>Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Namespace</td>\n<td>X</td>\n<td></td>\n<td>X</td>\n</tr>\n<tr>\n<td>Class</td>\n<td></td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>Enum</td>\n<td></td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>Interface</td>\n<td></td>\n<td>X</td>\n<td></td>\n</tr>\n<tr>\n<td>Type Alias</td>\n<td></td>\n<td>X</td>\n<td></td>\n</tr>\n<tr>\n<td>Function</td>\n<td></td>\n<td></td>\n<td>X</td>\n</tr>\n<tr>\n<td>Variable</td>\n<td></td>\n<td></td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<h2>接口合并</h2>\n<ol>\n<li>非函数声明应该是唯一，如果不唯一类型必须相同</li>\n<li>双方成员合会并到同名的接口中</li>\n<li>函数接口之间的顺序是后来的接口重载出现在靠前的位置</li>\n<li>函数签名里有一个参数的类型是 单一的字符串字面量则会提升至顶端</li>\n</ol>\n<pre><code class=\"language-ts\">interface Box {\n    height: number;\n    width: number;\n}\ninterface Box {\n    scale: number;\n}\n\nlet box: Box = {height: 5, width: 6, scale: 10};\n</code></pre>\n<pre><code class=\"language-ts\">interface Cloner {\n    clone(animal: Animal): Animal;\n}\ninterface Cloner {\n    clone(animal: Sheep): Sheep;\n}\ninterface Cloner {\n    clone(animal: Dog): Dog;\n    clone(animal: Cat): Cat;\n}\n\n// 三个接口合并成一个声明\ninterface Cloner {\n    clone(animal: Dog): Dog;\n    clone(animal: Cat): Cat;\n    clone(animal: Sheep): Sheep;\n    clone(animal: Animal): Animal;\n}\n</code></pre>\n<pre><code class=\"language-ts\">interface Document {\n    createElement(tagName: any): Element;\n}\ninterface Document {\n    createElement(tagName: \"div\"): HTMLDivElement;\n    createElement(tagName: \"span\"): HTMLSpanElement;\n}\ninterface Document {\n    createElement(tagName: string): HTMLElement;\n    createElement(tagName: \"canvas\"): HTMLCanvasElement;\n}\n\n// 合并后的顺序\ninterface Document {\n    createElement(tagName: \"canvas\"): HTMLCanvasElement;\n    createElement(tagName: \"div\"): HTMLDivElement;\n    createElement(tagName: \"span\"): HTMLSpanElement;\n    createElement(tagName: string): HTMLElement;\n    createElement(tagName: any): Element;\n}\n</code></pre>\n<h2>合并命名空间</h2>\n<ol>\n<li>模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口</li>\n<li>重名的命名空间会被添加已存在的模块中</li>\n</ol>\n<pre><code class=\"language-ts\">namespace Animals {\n    export class Zebra { }\n    let haveMuscles = true;\n    export function animalsHaveMuscles() {\n        return haveMuscles;\n    }\n}\nnamespace Animals {\n    export interface Legged { numberOfLegs: number; }\n    export class Dog { }\n}\n\n// 合并后\nnamespace Animals {\n    export interface Legged { numberOfLegs: number; }\n\n    export class Zebra { }\n    export class Dog { }\n    \n    export function doAnimalsHaveMuscles() {\n        return haveMuscles;  // &#x3C;-- error, haveMuscles is not visible here\n    }\n}\n</code></pre>\n<h2>命名空间与类的合并</h2>\n<p>如例：合并结果是一个类并带有一个内部类<code>AlbumLabel</code>。 你也可以使用命名空间为类增加一些静态属性</p>\n<pre><code class=\"language-ts\">class Album {\n    label: Album.AlbumLabel;\n}\nnamespace Album {\n    export class AlbumLabel { }\n}\n</code></pre>\n<h2>命名空间与函数的合并</h2>\n<p>合并后扩展它增加了一些属性</p>\n<pre><code class=\"language-ts\">function buildLabel(name: string): string {\n    return buildLabel.prefix + name + buildLabel.suffix;\n}\n\nnamespace buildLabel {\n    export let suffix = \"\";\n    export let prefix = \"Hello, \";\n}\n\nalert(buildLabel(\"Sam Smith\"));\n</code></pre>\n<h2>命名空间与枚举的合并</h2>\n<p>相似的，命名空间可以用来扩展枚举型：</p>\n<pre><code class=\"language-ts\">enum Color {\n    red = 1,\n    green = 2,\n    blue = 4\n}\n\nnamespace Color {\n    export function mixColor(colorName: string) {\n        if (colorName == \"yellow\") {\n            return Color.red + Color.green;\n        }\n        else if (colorName == \"white\") {\n            return Color.red + Color.green + Color.blue;\n        }\n        else if (colorName == \"magenta\") {\n            return Color.red + Color.blue;\n        }\n        else if (colorName == \"cyan\") {\n            return Color.green + Color.blue;\n        }\n    }\n}\n</code></pre>\n<h2>模块扩展</h2>\n<p>如例：编译器对 <code>Observable.prototype.map</code>一无所知。 你可以使用扩展模块来将它告诉编译器.</p>\n<pre><code class=\"language-ts\">// observable.ts stays the same\n// map.ts\nimport { Observable } from \"./observable\";\ndeclare module \"./observable\" {\n    interface Observable&#x3C;T> {\n        map&#x3C;U>(f: (x: T) => U): Observable&#x3C;U>;\n    }\n}\nObservable.prototype.map = function (f) {\n    // ... another exercise for the reader\n}\n\n\n// consumer.ts\nimport { Observable } from \"./observable\";\nimport \"./map\";\nlet o: Observable&#x3C;number>;\no.map(x => x.toFixed());\n</code></pre>","frontmatter":{"title":"类型的合并"}}},"pageContext":{"slug":"/notes/类型的合并/","tagPath":"/Typescript/类型的合并/"}}