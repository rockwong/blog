{"data":{"markdownRemark":{"html":"<h1>mpvue 及小程序开发问题</h1>\n<p>微信小程序脚手架遇到的部分问题，及解决方案。</p>\n<h2>主要生命周期</h2>\n<p><strong>页面的生命周期</strong></p>\n<p><code>onShow</code> 当小程序从后台进入显示，或者切换导航进入页面后\n<code>onHide</code> 当小程序从前台台进入后台，或小程序卸载后\n<code>onUnload</code> 页面卸载，通常页面跳转页面卸载触发。</p>\n<h2>样式问题</h2>\n<ol>\n<li>布局样式高度100% 无效的问题: <code>height:100%</code> -> <code>height:100vh</code></li>\n<li>标签加上 <code>hover-class</code> 点击后会应用改样式，类似于按钮的伪类 <code>:actived</code>, 在组件上添加 <code>hover-stop-propagation</code>为 <code>true</code> 后， 点击该按钮不会触发父组件的 <code>hover-class</code></li>\n</ol>\n<h2>组件命名</h2>\n<ol>\n<li>驼峰命名规则 <code>TopHeader</code> -> <code>&#x3C;top-header /></code></li>\n<li>组件命名规避微信自带的组件名称，否则会出现无法预料的情况。</li>\n</ol>\n<h1>二维码问题</h1>\n<ul>\n<li>小程序中，不支持长按识别二维码，和小程序码。</li>\n<li>可利用小程序 图片预览功能识别 小程序码并进行跳转，公众号二维码不能识别</li>\n<li>利用小程序 web-view 开放功能，在打开页面中显示 图片，进行长按识别，不过安卓一样不识别</li>\n<li>利用官方二维码生成，小程序二维码 必须将官方的api 加入白名单</li>\n</ul>\n<h2>UI 库</h2>\n<ol>\n<li>\n<p><code>WeUI for 小程序 为微信小程序量身设计</code> <a href=\"https://github.com/Tencent/weui-wxss\">https://github.com/Tencent/weui-wxss</a></p>\n</li>\n<li>\n<p><code>基于 mpvue 的 WeUi</code> 基于 mpvue 框架，重写 WeUI  <a href=\"https://kuangpf.com/mpvue-weui\">https://kuangpf.com/mpvue-weui</a></p>\n<ul>\n<li><code>button</code> 组件中的边框圆角样式在伪类 :after 中</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li><code>富文本显示（参考）</code> <a href=\"http://www.ifanr.com/minapp/1009197\">http://www.ifanr.com/minapp/1009197</a></li>\n</ol>\n<h2>设置计算值的函数不可用Ramda等函数封装</h2>\n<pre><code class=\"language-js\">  computed: {\n    userInfo: R.always('info') // 应该使用 ()=>'info'\n  }),\n</code></pre>\n<h2>scss的支持</h2>\n<p>安装相关依赖，并设置标签<code>&#x3C;style></code>属性 <code>lang=scss</code></p>\n<pre><code class=\"language-bash\">npm install sass-loader node-sass --save-dev\n</code></pre>\n<h2>绑定命名空间函数无法使用的问题</h2>\n<p> <code>mapState</code>, <code>mapGetters</code>, <code>mapActions</code> 和 <code>mapMutations</code> 无法使用的问题</p>\n<p> 命名空间辅助代码变得更可读，实际是相当于语法糖，需映射 <code>this.$store.XXXX</code>，故在创建store 时增加映射。</p>\n<pre><code class=\"language-js\">Vue.prototype.$store = store\n</code></pre>\n<h2>资源文件访问方式</h2>\n<p>图片等相关资源都放入 <code>static</code> 下，在页面中用根路径访问。</p>\n<pre><code>/static/**/*.jpg\n</code></pre>\n<h2>data 数据设置</h2>\n<p>将 <code>data</code> 中的字段值设置为 <code>undefined</code> 时，该操作不会生效，字段值会保持旧事，不是<code>undefined</code>;</p>\n<h2>引入 vuex module</h2>\n<p>利用 <code>require.context</code> 批量引入 <code>module</code> 文件，<code>namespaced</code> = pages下子文件夹名称。</p>\n<p>当<code>module</code>文件放入 <code>pages</code> 目录下,并以<code>module</code>为前缀命名，则自动引入<code>vuex modules</code>中。</p>\n<pre><code class=\"language-js\">// 自动引入 modules 文件\nconst requireModules = require.context(\n  // 其组件目录的相对路径\n  '../pages',\n  // 是否查询其子目录\n  true,\n  // 匹配基础组件文件名的正则表达式\n  /module\\w*\\.(js)$/\n)\n\nconst modulesObj = {}\nrequireModules.keys().forEach(fileName => {\n  // 获取组件配置\n  const modulesConfig = requireModules(fileName)\n\n  // 获取module 命名\n  const moduleName = fileName.replace(/^\\.\\/(\\w*).*$/, '$1')\n\n  // 获取导出的值\n  modulesObj[moduleName] = modulesConfig.default || modulesConfig\n})\nconst store = new Vuex.Store({\n  modules: modulesObj\n})\n</code></pre>\n<h2>wx 接口转 promise</h2>\n<pre><code class=\"language-js\">import wxp from 'minapp-api-promise'\n</code></pre>\n<h2>小程序接口获取二维码图片</h2>\n<p>需要后端支持，正式环境腾讯不容许前端直接调用 生成二维码的接口。</p>\n<p>在开发工具中忽略域名可以在前端展示生成并展示二维码</p>\n<ol>\n<li>图片展示 <code>&#x3C;image src=\"data:image/png;base64,{{imgUrl}}\"/></code></li>\n<li>通过 ACCESS_TOKEN 获取图片数据，请求参数添加 <code>responseType:'arraybuffer'</code></li>\n<li>获取二维码图片数据成功后 <code>self.imgUrl=wx.arrayBufferToBase64(res.data)</code></li>\n</ol>\n<h2>引用 统一fetch</h2>\n<p>引入第三方 fetch 并配置 cookie</p>\n<pre><code class=\"language-js\">import Fly from 'flyio/dist/npm/wx'\n\nconst fly = new Fly()\n\n// 配置请求基地址\nif (process.env.NODE_ENV === 'production') {\n  fly.config.baseURL = 'http://test.***.com/api/'\n} else {\n  fly.config.baseURL = 'http://test.***.com/api/'\n}\n\n// 添加请求拦截器\nfly.interceptors.request.use((config, promise) => {\n  // 给所有请求添加cookie\n  const cookie = wx.getStorageSync('cookie')\n  if (cookie) config.headers.cookie = cookie\n  // 可以通过promise.reject／resolve直接中止请求\n  // promise.resolve(\"fake data\")\n  return config\n})\n\n// 添加响应拦截器，响应拦截器会在then/catch处理之前执行\nfly.interceptors.response.use(\n  (response, promise) => {\n    // 将cookie存入storage中\n    console.log('response==', response)\n    let cookie = response.headers['Set-Cookie'] || response.headers['set-cookie']\n    console.log('cookie==', cookie)\n    if (cookie) wx.setStorageSync('cookie', cookie.replace(/(?!\\s),(?!\\s)/, '; '))\n\n    const data = response.data\n\n    // 自定义请求结果，如果status 不为'success',则认为请求失败（后端统一配置）\n    if (data.status === 'success') {\n      return data\n    } else {\n      return promise.reject(data)\n    }\n  },\n  (err, promise) => {\n    // 发生网络错误后会走到这里\n    promise.resolve(err)\n  }\n)\nexport default fly\n</code></pre>\n<h2>Cannot assign to read only property 'exports' of object '#<Object>' 编译报错</h2>\n<p>这是因为引用第三方插件的时候,带入了<code>module.exports</code>的写法\nwebpack可以使用require和export ，但是不能混合使用import 和module.exports,\n你需要做的是更新根目录下的<code>.babelrc</code>文件配置</p>","frontmatter":{"title":"mpvue 及小程序开发问题"}}},"pageContext":{"slug":"/notes/mpvue 及小程序开发问题/","tagPath":"/Vue/mpvue 及小程序开发问题/"}}