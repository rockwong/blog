{"data":{"markdownRemark":{"html":"<h1>npm scripts 使用指南</h1>\n<blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html\">http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html</a></p>\n</blockquote>\n<h2>原理</h2>\n<p>每当执行<code>npm run</code>，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。</p>\n<p>比较特别的是，<code>npm run</code>新建的这个 Shell，会将当前目录的<code>node_modules/.bin</code>子目录加入<code>PATH</code>变量，执行结束后，再将<code>PATH</code>变量恢复原样。</p>\n<p>这意味着，当前目录的<code>node_modules/.bin</code>子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写<code>mocha test</code>就可以了。</p>\n<pre><code class=\"language-javascript\">\"test\": \"mocha test\"\n</code></pre>\n<p>而不用写成下面这样。</p>\n<pre><code class=\"language-javascript\">\"test\": \"./node_modules/.bin/mocha test\"\n</code></pre>\n<p>由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。</p>\n<p>npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是<code>0</code>，npm 就认为这个脚本执行失败。</p>\n<h2>通配符</h2>\n<p>由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。</p>\n<pre><code class=\"language-javascript\">\"lint\": \"jshint *.js\"\n\"lint\": \"jshint **/*.js\"\n</code></pre>\n<p>上面代码中，<code>*</code>表示任意文件名，<code>**</code>表示任意一层子目录。</p>\n<p>如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。</p>\n<pre><code class=\"language-javascript\">\"test\": \"tap test/\\*.js\"\n</code></pre>\n<h2>传参</h2>\n<p>向 npm 脚本传入参数，要使用<code>--</code>标明。</p>\n<pre><code class=\"language-javascript\">\"lint\": \"jshint **.js\"\n</code></pre>\n<p>向上面的<code>npm run lint</code>命令传入参数，必须写成下面这样。</p>\n<pre><code class=\"language-bash\">$ npm run lint --  --reporter checkstyle > checkstyle.xml\n</code></pre>\n<p>也可以在<code>package.json</code>里面再封装一个命令。</p>\n<pre><code class=\"language-javascript\">\"lint\": \"jshint **.js\",\n\"lint:checkstyle\": \"npm run lint -- --reporter checkstyle > checkstyle.xml\"\n</code></pre>\n<h2>执行顺序</h2>\n<p>如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p>\n<p>如果是并行执行（即同时的平行执行），可以使用<code>&#x26;</code>符号。</p>\n<pre><code class=\"language-bash\">$ npm run script1.js &#x26; npm run script2.js\n</code></pre>\n<p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用<code>&#x26;&#x26;</code>符号。</p>\n<pre><code class=\"language-bash\">$ npm run script1.js &#x26;&#x26; npm run script2.js\n</code></pre>\n<p>这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：<a href=\"https://github.com/paulpflug/script-runner\">script-runner</a>、<a href=\"https://github.com/mysticatea/npm-run-all\">npm-run-all</a>、<a href=\"https://github.com/coderaiser/redrun\">redrun</a>。</p>\n<h2>默认值</h2>\n<p>一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。</p>\n<pre><code class=\"language-javascript\">\"start\": \"node server.js\"，\n\"install\": \"node-gyp rebuild\"\n</code></pre>\n<p>上面代码中，<code>npm run start</code>的默认值是<code>node server.js</code>，前提是项目根目录下有<code>server.js</code>这个脚本；<code>npm run install</code>的默认值是<code>node-gyp rebuild</code>，前提是项目根目录下有<code>binding.gyp</code>文件。</p>\n<h2>钩子</h2>\n<p>npm 脚本有<code>pre</code>和<code>post</code>两个钩子。举例来说，<code>build</code>脚本命令的钩子就是<code>prebuild</code>和<code>postbuild</code>。</p>\n<pre><code class=\"language-javascript\">\"prebuild\": \"echo I run before the build script\",\n\"build\": \"cross-env NODE_ENV=production webpack\",\n\"postbuild\": \"echo I run after the build script\"\n</code></pre>\n<p>用户执行<code>npm run build</code>的时候，会自动按照下面的顺序执行。</p>\n<pre><code class=\"language-bash\">npm run prebuild &#x26;&#x26; npm run build &#x26;&#x26; npm run postbuild\n</code></pre>\n<p>因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。</p>\n<pre><code class=\"language-javascript\">\"clean\": \"rimraf ./dist &#x26;&#x26; mkdir dist\",\n\"prebuild\": \"npm run clean\",\n\"build\": \"cross-env NODE_ENV=production webpack\"\n</code></pre>\n<p>npm 默认提供下面这些钩子。</p>\n<blockquote>\n<ul>\n<li>prepublish，postpublish</li>\n</ul>\n</blockquote>\n<ul>\n<li>preinstall，postinstall</li>\n<li>preuninstall，postuninstall</li>\n<li>preversion，postversion</li>\n<li>pretest，posttest</li>\n<li>prestop，poststop</li>\n<li>prestart，poststart</li>\n<li>prerestart，postrestart</li>\n</ul>\n<p>自定义的脚本命令也可以加上<code>pre</code>和<code>post</code>钩子。比如，<code>myscript</code>这个脚本命令，也有<code>premyscript</code>和<code>postmyscript</code>钩子。不过，双重的<code>pre</code>和<code>post</code>无效，比如<code>prepretest</code>和<code>postposttest</code>是无效的。</p>\n<p>npm 提供一个<code>npm_lifecycle_event</code>变量，返回当前正在运行的脚本名称，比如<code>pretest</code>、<code>test</code>、<code>posttest</code>等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的<code>npm scripts</code>命令编写代码。请看下面的例子。</p>\n<pre><code class=\"language-javascript\">const TARGET = process.env.npm_lifecycle_event;\n\nif (TARGET === 'test') {\n  console.log(`Running the test task!`);\n}\n\nif (TARGET === 'pretest') {\n  console.log(`Running the pretest task!`);\n}\n\nif (TARGET === 'posttest') {\n  console.log(`Running the posttest task!`);\n}\n</code></pre>\n<p>注意，<code>prepublish</code>这个钩子不仅会在<code>npm publish</code>命令之前运行，还会在<code>npm install</code>（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子<code>prepare</code>，行为等同于<code>prepublish</code>，而从 npm 5 开始，<code>prepublish</code>将只在<code>npm publish</code>命令之前运行。</p>\n<h2>简写形式</h2>\n<p>四个常用的 npm 脚本有简写形式。</p>\n<blockquote>\n<ul>\n<li><code>npm start</code>是<code>npm run start</code></li>\n</ul>\n</blockquote>\n<ul>\n<li><code>npm stop</code>是<code>npm run stop</code>的简写</li>\n<li><code>npm test</code>是<code>npm run test</code>的简写</li>\n<li><code>npm restart</code>是<code>npm run stop &#x26;&#x26; npm run restart &#x26;&#x26; npm run start</code>的简写</li>\n</ul>\n<p><code>npm start</code>、<code>npm stop</code>和<code>npm restart</code>都比较好理解，而<code>npm restart</code>是一个复合命令，实际上会执行三个脚本命令：<code>stop</code>、<code>restart</code>、<code>start</code>。具体的执行顺序如下。</p>\n<blockquote>\n<ol>\n<li>prerestart</li>\n</ol>\n</blockquote>\n<ol>\n<li>prestop</li>\n<li>stop</li>\n<li>poststop</li>\n<li>restart</li>\n<li>prestart</li>\n<li>start</li>\n<li>poststart</li>\n<li>postrestart </li>\n</ol>\n<h2>变量</h2>\n<p>npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。</p>\n<p>首先，通过<code>npm_package_</code>前缀，npm 脚本可以拿到<code>package.json</code>里面的字段。比如，下面是一个<code>package.json</code>。</p>\n<pre><code class=\"language-javascript\">{\n  \"name\": \"foo\", \n  \"version\": \"1.2.5\",\n  \"scripts\": {\n    \"view\": \"node view.js\"\n  }\n}\n</code></pre>\n<p>那么，变量<code>npm_package_name</code>返回<code>foo</code>，变量<code>npm_package_version</code>返回<code>1.2.5</code>。</p>\n<pre><code class=\"language-javascript\">// view.js\nconsole.log(process.env.npm_package_name); // foo\nconsole.log(process.env.npm_package_version); // 1.2.5\n</code></pre>\n<p>上面代码中，我们通过环境变量<code>process.env</code>对象，拿到<code>package.json</code>的字段值。如果是 Bash 脚本，可以用<code>$npm_package_name</code>和<code>$npm_package_version</code>取到这两个值。</p>\n<p><code>npm_package_</code>前缀也支持嵌套的<code>package.json</code>字段。</p>\n<pre><code class=\"language-javascript\">  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"xxx\"\n  },\n  scripts: {\n    \"view\": \"echo $npm_package_repository_type\"\n  }\n</code></pre>\n<p>上面代码中，<code>repository</code>字段的<code>type</code>属性，可以通过<code>npm_package_repository_type</code>取到。</p>\n<p>下面是另外一个例子。</p>\n<pre><code class=\"language-javascript\">\"scripts\": {\n  \"install\": \"foo.js\"\n}\n</code></pre>\n<p>上面代码中，<code>npm_package_scripts_install</code>变量的值等于<code>foo.js</code>。</p>\n<p>然后，npm 脚本还可以通过<code>npm_config_</code>前缀，拿到 npm 的配置变量，即<code>npm config get xxx</code>命令返回的值。比如，当前模块的发行标签，可以通过<code>npm_config_tag</code>取到。</p>\n<pre><code class=\"language-javascript\">\"view\": \"echo $npm_config_tag\",\n</code></pre>\n<p>注意，<code>package.json</code>里面的<code>config</code>对象，可以被环境变量覆盖。</p>\n<pre><code class=\"language-javascript\">{ \n  \"name\" : \"foo\",\n  \"config\" : { \"port\" : \"8080\" },\n  \"scripts\" : { \"start\" : \"node server.js\" }\n}\n</code></pre>\n<p>上面代码中，<code>npm_package_config_port</code>变量返回的是<code>8080</code>。这个值可以用下面的方法覆盖。</p>\n<pre><code class=\"language-bash\">$ npm config set foo:port 80\n</code></pre>\n<p>最后，<code>env</code>命令可以列出所有环境变量。</p>\n<pre><code class=\"language-javascript\">\"env\": \"env\"\n</code></pre>\n<h2>常用脚本示例</h2>\n<pre><code class=\"language-javascript\">// 删除目录\n\"clean\": \"rimraf dist/*\",\n\n// 本地搭建一个 HTTP 服务\n\"serve\": \"http-server -p 9090 dist/\",\n\n// 打开浏览器\n\"open:dev\": \"opener http://localhost:9090\",\n\n// 实时刷新\n \"livereload\": \"live-reload --port 9091 dist/\",\n\n// 构建 HTML 文件\n\"build:html\": \"jade index.jade > dist/index.html\",\n\n// 只要 CSS 文件有变动，就重新执行构建\n\"watch:css\": \"watch 'npm run build:css' assets/styles/\",\n\n// 只要 HTML 文件有变动，就重新执行构建\n\"watch:html\": \"watch 'npm run build:html' assets/html\",\n\n// 部署到 Amazon S3\n\"deploy:prod\": \"s3-cli sync ./dist/ s3://example-com/prod-site/\",\n\n// 构建 favicon\n\"build:favicon\": \"node scripts/favicon.js\",\n</code></pre>","frontmatter":{"title":"npm scripts 使用指南"}}},"pageContext":{"slug":"/notes/npm scripts 使用指南/","tagPath":"/node/npm scripts 使用指南/"}}