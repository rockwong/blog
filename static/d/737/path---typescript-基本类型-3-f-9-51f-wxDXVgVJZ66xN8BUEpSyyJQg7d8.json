{"data":{"markdownRemark":{"html":"<h1>基本类型</h1>\n<p><code>JavaScript</code> 的类型分为两种：\n原始数据类型（<code>Boolean</code>，<code>number</code>，<code>string</code>，<code>null</code>，<code>undefined</code>，<code>Synmbol</code>）和<code>对象类型</code>，</p>\n<p><code>TypeScript</code> 中原始类型数据也是使用。为了让程序有价值,需要能够处理最简单的数据单元，数字，字符串</p>\n<p><img src=\"media/15330939698527/15330940774141.jpg\"></p>\n<h2>数字,字符串，数组</h2>\n<pre><code class=\"language-ts\">let decLiteral:number = 6   //数字类型\nlet name1:string = 'bob'    //字符串类型\nlet sentence:string = `Hello, my name is ${name1}`    //字符串模板\nlet list0:number[] = [1,2,3,4]    //[]形式定义数组\nlet list1:string[]=['12','12','90']\nlet list2:Array&#x3C;number> = [1,23,4]    //Array&#x3C;元素类型>\nlet list3:Array&#x3C;string> = ['1','23','4']    //Array&#x3C;元素类型>\n</code></pre>\n<p><code>TypeScript</code> 中数组类型有多重定义方式，比较灵活</p>\n<pre><code class=\"language-ts\">// 类型 + 方括号 表示法\nlet fibonacci1:number[] = [1,2,3,4] //只能传number类型的，否则会提示错误\n\n// 数组泛型\nlet fibinacci2: Array&#x3C;number> = [1,2,3,4]\n\n// 用接口表示数组\ninterface NumberArray {\n    [index:number]: number\n}\nlet fibonacci3: NumberArray = [1,2,3,4]\n</code></pre>\n<h2>元组 Tuple</h2>\n<p>已知元素数量和类型的数组，各元素的类型不必相同</p>\n<pre><code class=\"language-ts\">// Declare a tuple type\nlet x: [string, number];\n\nx = ['hello', 10]; // OK\n\nx = [10, 'hello']; // Error\n</code></pre>\n<h2>枚举：取值被限定在一定范围内的场景</h2>\n<ul>\n<li>默认从0开始为元素编号，其余成员自动增长，也可以手动指定元素编号</li>\n<li>可以通过元素编号获取它的名字(字符串编号默认不能，除非用类型断言无视类型检查)</li>\n<li>使用 <code>const</code> 定义枚举时，在编译阶段会被删除，在使用的地方会别内联进来</li>\n<li>使用 <code>declare</code> 定义枚举时，在编译阶段会被删除，在使用的地方不会内联进来</li>\n</ul>\n<pre><code class=\"language-ts\">enum Color { Red,Green,Blue}\nlet c:Color = Color.Green  // c = 1\n\nconst enum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2]; // colorName= 'Green'\n</code></pre>\n<h2>Any</h2>\n<p>编程阶段还不清楚类型的变量指定一个类型。\n<code>any</code> 与 <code>Object</code> 类型的区别是，<code>object</code>值容许你赋值任意类型的值，却不能在上面调用任意的方法，即使真有这些方法。</p>\n<pre><code class=\"language-ts\">let notSure: any = 4;\nnotSure.ifItExists(); // okay, ifItExists might exist at runtime\nnotSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)\n\nlet prettySure: Object = 4;\nprettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.\n\n// 定义不同类型的数组\nlet list: any[] = [1, true, \"free\"]; list[1] = 100;\n</code></pre>\n<h2>Void</h2>\n<p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型.\n当函数没有返回值时，他的返回值是Void.</p>\n<pre><code class=\"language-js\">function warnUser(): void {\n    alert(\"This is my warning message\");\n}\n\n// void类型的变量没有什么大用，因为你只能为它赋予undefined和null\nlet unusable: void = undefined;\n</code></pre>\n<h2>Null 和 Undefined</h2>\n<ul>\n<li><code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code></li>\n<li>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型,可以把 <code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量</li>\n<li>你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自</li>\n</ul>\n<h2>Never</h2>\n<p><code>never</code>类型表示的是那些永不存在的值的类型.\n<code>never</code>类型是任何类型的子类型</p>\n<pre><code class=\"language-ts\">// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\n</code></pre>\n<h2>类型断言</h2>\n<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。</p>\n<pre><code class=\"language-ts\">let someValue:any = \"this is a string\"\nlet strLength:number = (&#x3C;string>someValue).length//“尖括号”语法\nlet strLength1: number = (someValue as string).length;//一个为as语法 (JSX 只有 as 被容许)\n</code></pre>\n<h2>联合类型</h2>\n<p>表示取值可以是多种类型中的一种</p>\n<pre><code class=\"language-ts\">let myFavoriteNumber:string|number; // 连接符 |\nmyFavoriteNumber = 'seven'\nmyFavoriteNumber = 7\n</code></pre>","frontmatter":{"title":"基本类型"}}},"pageContext":{"slug":"/notes/基本类型/","tagPath":"/Typescript/基本类型/"}}