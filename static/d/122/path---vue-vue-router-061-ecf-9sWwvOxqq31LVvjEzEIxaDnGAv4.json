{"data":{"markdownRemark":{"html":"<h1>Vue router</h1>\n<p>路由配置与react-router 相仿</p>\n<h2>html</h2>\n<pre><code class=\"language-html\">&#x3C;div id=\"app\">\n  &#x3C;h1>Hello App!&#x3C;/h1>\n  &#x3C;p>\n    &#x3C;!-- 使用 router-link 组件来导航. -->\n    &#x3C;!-- 通过传入 `to` 属性指定链接. -->\n    &#x3C;!-- &#x3C;router-link> 默认会被渲染成一个 `&#x3C;a>` 标签 -->\n    &#x3C;router-link to=\"/foo\">Go to Foo&#x3C;/router-link>\n    &#x3C;router-link to=\"/bar\">Go to Bar&#x3C;/router-link>\n  &#x3C;/p>\n  &#x3C;!-- 路由出口 -->\n  &#x3C;!-- 路由匹配到的组件将渲染在这里 -->\n  &#x3C;router-view>&#x3C;/router-view>\n&#x3C;/div>\n</code></pre>\n<h2>javaScript</h2>\n<pre><code class=\"language-js\">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)\n\n// 1. 定义 (路由) 组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: '&#x3C;div>foo&#x3C;/div>' }\nconst Bar = { template: '&#x3C;div>bar&#x3C;/div>' }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中\"component\" 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: '/foo', component: Foo },\n  { path: '/bar', component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // (缩写) 相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  router\n}).$mount('#app')\n\n// 现在，应用已经启动了！\n</code></pre>\n<h2>组件内部访问路由</h2>\n<pre><code class=\"language-js\">// Home.vue\nexport default {\n  computed: {\n    username () {\n      // 我们很快就会看到 `params` 是什么\n      return this.$route.params.username\n    }\n  },\n  methods: {\n    goBack () {\n      window.history.length > 1\n        ? this.$router.go(-1)\n        : this.$router.push('/')\n    }\n  }\n}\n</code></pre>\n<h2>响应路由参数的变化</h2>\n<ul>\n<li>watch <code>$route</code> 对象</li>\n</ul>\n<pre><code class=\"language-js\">const User = {\n  template: '...',\n  watch: {\n    '$route' (to, from) {\n      // 对路由变化作出响应...\n    }\n  }\n}\n</code></pre>\n<ul>\n<li><code>beforeRouteUpdate</code> 钩子函数</li>\n</ul>\n<pre><code class=\"language-js\">const User = {\n  template: '...',\n  beforeRouteUpdate (to, from, next) {\n    // react to route changes...\n    // don't forget to call next()\n  }\n}\n</code></pre>\n<h2>路由嵌套</h2>\n<pre><code class=\"language-js\">const User = {\n  template: `\n    &#x3C;div class=\"user\">\n      &#x3C;h2>User {{ $route.params.id }}&#x3C;/h2>\n      &#x3C;router-view>&#x3C;/router-view>\n    &#x3C;/div>\n  `\n}\nconst router = new VueRouter({\n  routes: [\n    { path: '/user/:id', component: User,\n      children: [\n        {\n          // 当 /user/:id/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 &#x3C;router-view> 中\n          path: 'profile',\n          component: UserProfile\n        },\n        {\n          // 当 /user/:id/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 &#x3C;router-view> 中\n          path: 'posts',\n          component: UserPosts\n        }\n      ]\n    }\n  ]\n})\n</code></pre>\n<h2>router 方法</h2>\n<h3>router.push(location, onComplete?, onAbort?)</h3>\n<ol>\n<li>在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code></li>\n<li>点击 <code>&#x3C;router-link :to=\"...\"></code> 会内部调用 <code>router.push(...)</code> 实现</li>\n<li>会想 history 栈添加一个新的记录</li>\n</ol>\n<pre><code class=\"language-js\">// 字符串\nrouter.push('home')\n\n// 命名的路由，如果参数对象中含有path,则会忽略 params\nrouter.push({ name: 'user', params: { userId: 123 }}) // -> /user/123\n//同 &#x3C;router-link :to=\"{ name: 'user', params: { userId: 123 }}\">User&#x3C;/router-link>\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n</code></pre>\n<h3>router.replace(location, onComplete?, onAbort?)</h3>\n<p>同<code>router.push</code>,不会将 history 放入栈记录中。</p>\n<h3>router.go(n)</h3>\n<p>参数是一个整数在 history 记录中向前或者后退多少步，类似 window.history.go(n)</p>\n<h2>视图命名 <router-view name=\"a\" /></h2>\n<p>在根目录时分别展示：</p>\n<ol>\n<li>view 为 default的<code>Foo</code>组件</li>\n<li>view 为 a 的<code>Bar</code>组件</li>\n<li>view 为 b的<code>Baz</code>组件</li>\n</ol>\n<pre><code class=\"language-jsx\">const Foo = { template: '&#x3C;div>foo&#x3C;/div>' }\nconst Bar = { template: '&#x3C;div>bar&#x3C;/div>' }\nconst Baz = { template: '&#x3C;div>baz&#x3C;/div>' }\n\n&#x3C;!--没有名字的router-view默认为default-->\n&#x3C;router-view class=\"view one\">&#x3C;/router-view>\n&#x3C;router-view class=\"view two\" name=\"a\">&#x3C;/router-view>\n&#x3C;router-view class=\"view three\" name=\"b\">&#x3C;/router-view>\n\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/',\n      components: {\n        default: Foo,\n        a: Bar,\n        b: Baz\n      }\n    }\n  ]\n})\n</code></pre>\n<h2>重定向</h2>\n<pre><code class=\"language-js\">const router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: '/b' },\n    { path: '/c', redirect: { name: 'foo' }},\n    { path: '/d', redirect: to => {\n      // 方法接收 目标路由 作为参数\n      // return 重定向的 字符串路径/路径对象\n    }},\n    \n    // alias: url 保持 a 不变,路由匹配 b\n    { path: '/a', component: A, alias: '/b' }，\n  ]\n})\n</code></pre>\n<h2>路由传参</h2>\n<pre><code class=\"language-js\"># 通过 props 解耦\n\nconst User = {\n  props: ['id'],\n  template: '&#x3C;div>User {{ id }}&#x3C;/div>'\n}\nconst router = new VueRouter({\n  routes: [\n    { path: '/user/:id', component: User, props: true },\n\n    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：\n    {\n      path: '/user/:id',\n      components: { default: User, sidebar: Sidebar },\n      props: { default: true, sidebar: false }\n    }\n  ]\n})\n\n这样你便可以在任何地方使用该组件，使得该组件更易于重用和测试。\n\n# 布尔模式\n如果 props 被设置为 true，route.params 将会被设置为组件属性。\n\n# 对象模式\n如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。\n\nconst router = new VueRouter({\n  routes: [\n    { path: '/promotion/from-newsletter', component: Promotion, props: { newsletterPopup: false } }\n  ]\n})\n\n# 函数模式\n\n你可以创建一个函数返回 props。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。\n\nconst router = new VueRouter({\n  routes: [\n    { path: '/search', component: SearchUser, props: (route) => ({ query: route.query.q }) }\n  ]\n})\n\nURL /search?q=vue 会将 {query: 'vue'} 作为属性传递给 SearchUser 组件。\n</code></pre>\n<h2>路由守卫</h2>\n<p><code>全局守卫(router.beforeEach)</code></p>\n<pre><code class=\"language-js\">const router = new VueRouter({ ... })\n\nrouter.beforeEach((to, from, next) => {\n  // ...\n})\n每个守卫方法接收三个参数：\nto: Route: 即将要进入的目标 路由对象\nfrom: Route: 当前导航正要离开的路由\nnext: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。\n  next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是  confirmed （确认的）。\n  next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。\n  next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。\n  next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。\n  确保要调用 next 方法，否则钩子就不会被 resolved。\n</code></pre>\n<p><code>全局解析守卫(router.beforeResolve)</code></p>\n<p>全局前置守卫区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p>\n<p><code>全局后置钩子(router.afterEach)</code></p>\n<p>和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：</p>\n<pre><code class=\"language-js\">router.afterEach((to, from) => {\n  // ...\n})\n</code></pre>\n<h3>路由独享的守卫(beforeEnter)</h3>\n<pre><code class=\"language-js\">const router = new VueRouter({\n  routes: [\n    {\n      path: '/foo',\n      component: Foo,\n      beforeEnter: (to, from, next) => {\n        // ...\n      }\n    }\n  ]\n})\n</code></pre>\n<h3>组件内的守卫</h3>\n<ol>\n<li>beforeRouteEnter</li>\n<li>beforeRouteUpdate</li>\n<li>beforeRouteLeave</li>\n</ol>\n<pre><code class=\"language-js\">const Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n     next(vm => {\n        // 通过 `vm` 访问组件实例\n      })\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n    const answer = window.confirm('Do you really want to leave? you have unsaved changes!')\n      if (answer) next()\n      else next(false)\n  }\n}\n</code></pre>\n<h3>完整流程</h3>\n<ol>\n<li>导航被触发。</li>\n<li>在失活的组件里调用离开守卫。</li>\n<li>调用全局的 <code>beforeEach</code> 守卫。</li>\n<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li>\n<li>在路由配置里调用 <code>beforeEnter</code>。</li>\n<li>解析异步路由组件。</li>\n<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>\n<li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li>\n<li>导航被确认。</li>\n<li>调用全局的 <code>afterEach</code> 钩子。</li>\n<li>触发 DOM 更新。</li>\n<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li>\n</ol>\n<h2>路由元信息</h2>\n<pre><code class=\"language-js\">// 配置 meta 字段\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/foo',\n      component: Foo,\n      children: [\n        {\n          path: 'bar',\n          component: Bar,\n          // a meta field\n          meta: { requiresAuth: true }\n        }\n      ]\n    }\n  ]\n})\n\n// 检查元字段\nrouter.beforeEach((to, from, next) => {\n  if (to.matched.some(record => record.meta.requiresAuth)) {\n    // this route requires auth, check if logged in\n    // if not, redirect to login page.\n    if (!auth.loggedIn()) {\n      next({\n        path: '/login',\n        query: { redirect: to.fullPath }\n      })\n    } else {\n      next()\n    }\n  } else {\n    next() // 确保一定要调用 next()\n  }\n})\n</code></pre>\n<h2>过度效果</h2>\n<pre><code class=\"language-js\">// 单个效果\nconst Foo = {\n  template: `\n    &#x3C;transition name=\"slide\">\n      &#x3C;div class=\"foo\">...&#x3C;/div>\n    &#x3C;/transition>\n  `\n}\n\n// 动态过渡\n// &#x3C;!-- 使用动态的 transition name -->\n&#x3C;transition :name=\"transitionName\">\n  &#x3C;router-view>&#x3C;/router-view>\n&#x3C;/transition>\n// 接着在父组件内\n// watch $route 决定使用哪种过渡\nwatch: {\n  '$route' (to, from) {\n    const toDepth = to.path.split('/').length\n    const fromDepth = from.path.split('/').length\n    this.transitionName = toDepth &#x3C; fromDepth ? 'slide-right' : 'slide-left'\n  }\n}\n</code></pre>","frontmatter":{"title":"Vue router"}}},"pageContext":{"slug":"/notes/Vue router/","tagPath":"/Vue/Vue router/"}}