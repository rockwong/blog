{"data":{"markdownRemark":{"html":"<h1>Schema</h1>\n<h2>对象类型和字段（Object Types and Fields）</h2>\n<p>它就表示你可以从服务上获取到什么类型的对象，以及这个对象有什么字段</p>\n<pre><code>type Character {\n  name: String!\n  appearsIn: [Episode]!\n}\n</code></pre>\n<ul>\n<li><code>Character</code> 是一个 <code>GraphQL对象类型</code>，表示其是一个拥有一些字段的类型。 <code>schema</code> 中的大多数类型都会是对象类型。</li>\n<li><code>name</code> 和 <code>appearsIn</code> 是 <code>Character</code> 类型上的<code>字段</code>。这意味着在一个操作 <code>Character</code> 类型的 GraphQL 查询中的任何部分，都只能出现 <code>name</code> 和 <code>appearsIn</code> 字段。</li>\n<li><code>String</code> 是内置的<code>标量类型</code>之一 —— 标量类型是解析到单个标量对象的类型，无法在查询中对它进行次级选择。后面我们将细述标量类型。</li>\n<li><code>String!</code> 表示这个字段是<code>非空的</code>，GraphQL 服务保证当你查询这个字段后总会给你返回一个值。在类型语言里面，我们用一个感叹号来表示这个特性。</li>\n<li><code>[Episode]!</code> 表示一个 <code>Episode</code> 数组。因为它也是非空的，所以当你查询 <code>appearsIn</code> 字段的时候，你也总能得到一个数组（零个或者多个元素）。</li>\n</ul>\n<h2>参数（Arguments）</h2>\n<pre><code>type Starship {\n  id: ID!\n  name: String!\n  length(unit: LengthUnit = METER): Float\n}\n</code></pre>\n<p><code>length</code> 字段定义了一个参数，<code>unit</code></p>\n<p>参数可能是必选或者可选的，当一个参数是可选的，可以定义一个默认值 —— 如果 <code>unit</code> 参数没有传递，那么它将会被默认设置为 <code>METER</code></p>\n<h2>查询和变更类型（The Query and Mutation Types）</h2>\n<p><code>schema</code> 内有两个特殊类型</p>\n<pre><code># 内置特殊类型\nschema {\n  query: Query\n  mutation: Mutation\n}\n\n# 简单的查询示例\nquery {\n  hero {\n    name\n  }\n  droid(id: \"2000\") {\n    name\n  }\n}\n\n# 需要配置Query 类型\ntype Query {\n  hero(episode: Episode): Character\n  droid(id: ID!): Droid\n}\n</code></pre>\n<h2>标量类型（Scalar Types）</h2>\n<p>解析到具体数据的类型，示例查询中 <code>name</code> 和 <code>appearsIn</code> 将解析到标量类型。</p>\n<p>GraphQL 自带一组默认标量类型</p>\n<ul>\n<li><code>Int</code>：有符号 32 位整数。</li>\n<li><code>Float</code>：有符号双精度浮点值。</li>\n<li><code>String</code>：UTF‐8 字符序列。</li>\n<li><code>Boolean</code>：<code>true</code> 或者 <code>false</code>。</li>\n<li><code>ID</code>：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。</li>\n</ul>\n<pre><code>{\n  hero {\n    name\n    appearsIn\n  }\n}\n</code></pre>\n<pre><code># 自定义标量类型\nscalar Date\n</code></pre>\n<h2>枚举类型 (Enumeration Types）</h2>\n<p>限制在一个特殊的可选值集合内</p>\n<ol>\n<li>验证这个类型的任何参数是可选值的的某一个</li>\n<li>与类型系统沟通，一个字段总是一个有限值集合的其中一个值</li>\n</ol>\n<pre><code>enum Episode {\n  NEWHOPE\n  EMPIRE\n  JEDI\n}\n</code></pre>\n<p>schema 的哪处使用了 Episode，都可以肯定它返回的是 NEWHOPE、EMPIRE 和 JEDI 之一</p>\n<h2>接口（Interfaces）</h2>\n<p>一个<code>接口</code>是一个抽象类型，它包含某些字段，而对象类型必须包含这些字段，才能算实现了这个接口。</p>\n<p><code>Character</code> 接口用以表示《星球大战》三部曲中的任何角色：</p>\n<pre><code>interface Character {\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n}\n</code></pre>\n<p><code>实现 Character</code> 的类型都要具有这些字段，并有对应参数和返回类型.</p>\n<pre><code>type Human implements Character {\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n  starships: [Starship]\n  totalCredits: Int\n}\n\ntype Droid implements Character {\n  id: ID!\n  name: String!\n  friends: [Character]\n  appearsIn: [Episode]!\n  primaryFunction: String\n}\n</code></pre>\n<p>两个类型都具备 <code>Character</code> 接口的所有字段，但也引入了其他的字段 <code>totalCredits</code>、<code>starships</code> 和 <code>primaryFunction</code>，这都属于特定的类型的角色。</p>\n<p>查询一个只存在于特定对象类型上的字段，你需要使用内联片段</p>\n<pre><code>query HeroForEpisode($ep: Episode!) {\n  hero(episode: $ep) {\n    name\n    ... on Droid {\n      primaryFunction\n    }\n  }\n}\n# VARIABLES\n{\n  \"ep\": \"JEDI\"\n}\n</code></pre>\n<h2>联合类型（Union Types）</h2>\n<p>联合类型和接口十分相似，但是它并不指定类型之间的任何共同字段。</p>\n<pre><code>union SearchResult = Human | Droid | Starship\n</code></pre>\n<p>任何返回一个 <code>SearchResult</code> 类型的地方，都可能得到一个 <code>Human</code>、<code>Droid</code> 或者 <code>Starship</code>。注意，联合类型的成员需要是具体对象类型；你不能使用接口或者其他联合类型来创造一个联合类型。</p>\n<p>要查询一个返回 <code>SearchResult</code> 联合类型的字段，那么你得使用条件片段才能查询任意字段。</p>\n<pre><code>{\n  search(text: \"an\") {\n    ... on Human {\n      name\n      height\n    }\n    ... on Droid {\n      name\n      primaryFunction\n    }\n    ... on Starship {\n      name\n      length\n    }\n  }\n}\n</code></pre>\n<h2>输入类型（Input Types）</h2>\n<p>看上去和常规对象一模一样，除了关键字是 <code>input</code> 而不是 <code>type</code></p>\n<pre><code>input ReviewInput {\n  stars: Int!\n  commentary: String\n}\n</code></pre>\n<p>引用示例</p>\n<pre><code>mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n  createReview(episode: $ep, review: $review) {\n    stars\n    commentary\n  }\n}\n# VARIABLES\n{\n  \"ep\": \"JEDI\",\n  \"review\": {\n    \"stars\": 5,\n    \"commentary\": \"This is a great movie!\"\n  }\n}\n</code></pre>\n<p>输入对象类型上的字段本身也可以指代输入对象类型，但是你不能在你的 schema 混淆输入和输出类型。输入对象类型的字段当然也不能拥有参数。</p>","frontmatter":{"title":"Schema"}}},"pageContext":{"slug":"/notes/Schema/","tagPath":"/Gatsby/Schema/"}}