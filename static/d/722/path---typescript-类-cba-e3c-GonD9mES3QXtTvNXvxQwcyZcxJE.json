{"data":{"markdownRemark":{"html":"<h1>类</h1>\n<p><img src=\"media/15331136386590/15331136529051.jpg\"></p>\n<h2>类的修饰器</h2>\n<p><code>public</code> 在 TypeScript 中，成员属性默认为 public</p>\n<p><code>private</code> 不能声明它的外部访问</p>\n<p><code>protected</code> 与 <code>private</code>类似，但在继承类中仍然可以访问</p>\n<p><code>readonly</code> 关键字将属性设置为只读，只读属性必须在声明或者构造函数里被初始化</p>\n<h2>存取器</h2>\n<p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问.</p>\n<p>如果访问对象只设置 <code>getters</code>，没有设置<code>setters</code>则认为该属性为只读。</p>\n<pre><code class=\"language-ts\">let passcode = 'secret passcode'\nclass Employee {\n  private _fullName:string;\n  get fullName():string {\n    return this._fullName\n  }\n  set fullName(newName:string){\n    if (passcode &#x26;&#x26; passcode == \"secret passcode\") {\n      this._fullName = newName\n    } else {\n      console.log(\"Error: Unauthorized update of employee!\");\n    }\n  }\n}\nlet employee = new Employee();\nemployee.fullName = \"Bob Smith\";\nif (employee.fullName) {\n    alert(employee.fullName);\n}\n</code></pre>\n<h2>抽象类</h2>\n<p>派生类的基类使用，不会能直接被实例化\n抽象类中的<code>抽象方法</code>不包含具体实现并且必须在派生类中实现\n抽象类和可包含成员的实现细节，必须包含 <code>abstract</code> 关键字标识和访问修饰符</p>\n<pre><code class=\"language-ts\">abstract class Department {\n    constructor(public name: string) {}\n    printName(): void {\n        console.log('Department name: ' + this.name);\n    }\n    abstract printMeeting(): void; // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n    constructor() {\n        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()\n    }\n    printMeeting(): void {\n        console.log('The Accounting Department meets each Monday at 10am.');\n    }\n    generateReports(): void {\n        console.log('Generating accounting reports...');\n    }\n}\n\nlet department: Department; // 允许创建一个对抽象类型的引用\ndepartment = new Department(); // 错误: 不能创建一个抽象类的实例\ndepartment = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // 错误: 方法在声明的抽象类中不存在\n</code></pre>\n<h2>类可以当着类型接口使用</h2>\n<p>类定义会创建两个东西：<code>类的实例</code>和 <code>一个构造函数</code>，类可以创建类型，所以你能够在允许使用接口的地方使用类</p>\n<pre><code class=\"language-ts\">class Point {\n  x:number;\n  y:number;\n}\ninterface Point3d extends Point {\n  z:number\n}\nlet point3d:Point3d = {x:1,y:2,z:3}\n</code></pre>\n<h2>内置对象</h2>\n<p><code>JavaScript</code> 内置对象，直接在 <code>TypeScript</code> 中当做定义好了的类型</p>\n<pre><code class=\"language-ts\">let b:Boolean = new Boolean(1)\nlet c:Error = new Error('Error occurred')\nlet d:Date = new Date()\nlet r:RegExp = /[a-z]/\n</code></pre>","frontmatter":{"title":"类"}}},"pageContext":{"slug":"/notes/类/","tagPath":"/Typescript/类/"}}