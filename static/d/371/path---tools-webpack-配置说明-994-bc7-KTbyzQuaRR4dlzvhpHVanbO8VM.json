{"data":{"markdownRemark":{"html":"<h1>Webpack 配置说明</h1>\n<blockquote>\n<p>参考:<a href=\"http://www.cnblogs.com/vajoy/p/4650467.html\">http://www.cnblogs.com/vajoy/p/4650467.html</a></p>\n</blockquote>\n<h2>实例配置</h2>\n<pre><code class=\"language-js\">var webpack = require('webpack');\nvar commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');\n\nmodule.exports = {\n    //插件项\n    plugins: [commonsPlugin],\n    //页面入口文件配置\n    entry: {\n        index : './src/js/page/index.js'\n    },\n    //入口文件输出配置\n    output: {\n        path: 'dist/js/page',\n        filename: '[name].js'\n    },\n    module: {\n        //加载器配置\n        loaders: [\n            { test: /\\.css$/, loader: 'style-loader!css-loader' },\n            { test: /\\.js$/, loader: 'jsx-loader?harmony' },\n            { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'},\n            { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\n        ]\n    },\n    //其它解决方案配置\n    resolve: {\n        root: 'E:/github/flux-example/src', //绝对路径\n        extensions: ['', '.js', '.json', '.scss'],\n        alias: {\n            AppStore : 'js/stores/AppStores.js',\n            ActionType : 'js/actions/ActionType.js',\n            AppAction : 'js/actions/AppAction.js'\n        }\n    }\n};\n</code></pre>\n<h2>entry</h2>\n<p>页面入口文件配置,支持字符串及数组形式</p>\n<pre><code class=\"language-js\">//string\nentry: \"./entry1\"\n\n//array\nentry: [\"./entry1\", \"./entry2\"]\n\n//objact\nentry: {\n        page1: \"./page1\",\n        page2: [\"./entry1\", \"./entry2\"]\n    },\n    output: {\n        // Make sure to use [name] or [id] in output.filename\n        filename: \"[name].bundle.js\",\n        chunkFilename: \"[id].bundle.js\"\n    }\n</code></pre>\n<h2>output</h2>\n<p>输出配置项(即入口文件最终要生成什么名字的文件、存放到哪里)\n[id] 输入文件的序列\n[name] 输入对象的key值如: page1,page2\n[hash] 文件的hash值\n[chunkhash] chunk的文件hash</p>\n<p><strong>chunkFilename</strong>\n未被列在entry中，却又需要被打包出来的文件命名配置。</p>\n<pre><code class=\"language-js\"> output: {\n        path: \"dist/js/page\",\n        filename: \"[name].bundle.js\",\n        chunkFilename: \"[id].bundle.js\"\n    }\n</code></pre>\n<h2>module</h2>\n<p>是最关键的一块配置,它告知 webpack 每一种文件都需要使用什么加载器来处理\n如上，\"-loader\"其实是可以省略不写的，多个loader之间用“!”连接起来。\n所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。</p>\n<pre><code class=\"language-js\">module: {\n        //加载器配置\n        loaders: [\n            //.css 文件使用 style-loader 和 css-loader 来处理\n            { test: /\\.css$/, loader: 'style-loader!css-loader' },\n            //.js 文件使用 jsx-loader 来编译处理\n            { test: /\\.js$/, loader: 'jsx-loader?harmony' },\n            //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理\n            { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'},\n            //图片文件使用 url-loader 来处理，小于8kb的直接转为base64\n            { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\n        ]\n    }\n</code></pre>\n<h2>resolve</h2>\n<pre><code class=\"language-js\">resolve: {\n        //查找module的话从这里开始查找\n        root: 'E:/github/flux-example/src', //绝对路径\n        //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名\n        extensions: ['', '.js', '.json', '.scss'],\n        //模块别名定义，方便后续直接引用别名，无须多写长长的地址\n        alias: {\n            AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可\n            ActionType : 'js/actions/ActionType.js',\n            AppAction : 'js/actions/AppAction.js'\n        }\n    }\n</code></pre>\n<h2>运行参数</h2>\n<pre><code class=\"language-js\">$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包\n\n$ webpack --watch   //监听变动并自动打包\n\n$ webpack -p    //压缩混淆脚本，这个非常非常重要！\n\n$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了\n</code></pre>\n<h2>html</h2>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html>\n&#x3C;head lang=\"en\">\n  &#x3C;meta charset=\"UTF-8\">\n  &#x3C;title>demo&#x3C;/title>\n&#x3C;/head>\n&#x3C;body>\n  &#x3C;script src=\"dist/js/page/common.js\">&#x3C;/script>\n  &#x3C;script src=\"dist/js/page/index.js\">&#x3C;/script>\n&#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<h2>js</h2>\n<p>各脚本模块可以直接使用 commonJS 来书写，并可以直接引入未经编译的模块，比如 JSX、sass、coffee等（只要你在 webpack.config.js 里配置好了对应的加载器）。\n编译前的页面入口文件（index.js）：</p>\n<pre><code class=\"language-js\">require('../../css/reset.scss'); //加载初始化样式\nrequire('../../css/allComponent.scss'); //加载组件样式\nvar React = require('react');\nvar AppWrap = require('../component/AppWrap'); //加载组件\nvar createRedux = require('redux').createRedux;\nvar Provider = require('redux/react').Provider;\nvar stores = require('AppStore');\n\nvar redux = createRedux(stores);\n\nvar App = React.createClass({\n    render: function() {\n        return (\n            &#x3C;Provider redux={redux}>\n                {function() { return &#x3C;AppWrap />; }}\n            &#x3C;/Provider>\n        );\n    }\n});\n\nReact.render(\n    &#x3C;App />, document.body\n);\n</code></pre>\n<h2>shimming</h2>\n<p>在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用<code>exports-loader</code> 来帮忙：</p>\n<pre><code class=\"language-js\">{ test: require.resolve(\"./src/js/tool/swipe.js\"),  loader: \"exports?swipe\"}\n</code></pre>\n<p>之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：</p>\n<pre><code class=\"language-js\">require('./tool/swipe.js');\nswipe(); \n</code></pre>\n<h2>自定义公共模块提取</h2>\n<p>在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。\n更加个性化一些，可以这样配置：</p>\n<pre><code class=\"language-js\">var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");\nmodule.exports = {\n    entry: {\n        p1: \"./page1\",\n        p2: \"./page2\",\n        p3: \"./page3\",\n        ap1: \"./admin/page1\",\n        ap2: \"./admin/page2\"\n    },\n    output: {\n        filename: \"[name].js\"\n    },\n    plugins: [\n        new CommonsChunkPlugin(\"admin-commons.js\", [\"ap1\", \"ap2\"]),\n        new CommonsChunkPlugin(\"commons.js\", [\"p1\", \"p2\", \"admin-commons.js\"])\n    ]\n};\n// &#x3C;script>s required:\n// page1.html: commons.js, p1.js\n// page2.html: commons.js, p2.js\n// page3.html: p3.js\n// admin-page1.html: commons.js, admin-commons.js, ap1.js\n// admin-page2.html: commons.js, admin-commons.js, ap2.js\n</code></pre>\n<h2>独立打包样式文件</h2>\n<p>有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以<link>标签引入。这时候我们需要 <code>extract-text-webpack-plugin</code> 来帮忙：</p>\n<pre><code class=\"language-js\">var webpack = require('webpack');\n    var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');\n    var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n\n    module.exports = {\n        plugins: [commonsPlugin, new ExtractTextPlugin(\"[name].css\")],\n        entry: {\n        //...省略其它配置\n</code></pre>\n<h2>使用CDN/远程文件</h2>\n<p>有时候我们希望某些模块走CDN并以<code>&#x3C;script></code>的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。\n这时候我们可以在配置文件里使用 externals 属性来帮忙：\n需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。</p>\n<pre><code class=\"language-js\">{\n    externals: {\n        // require(\"jquery\") 是引用自外部模块的\n        // 对应全局变量 jQuery\n        \"jquery\": \"jQuery\"\n    }\n}\n</code></pre>","frontmatter":{"title":"Webpack 配置说明"}}},"pageContext":{"slug":"/notes/Webpack 配置说明/","tagPath":"/Tools/Webpack 配置说明/"}}