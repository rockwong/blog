{"data":{"markdownRemark":{"html":"<h1>接口</h1>\n<p><code>TypeScript</code> 核心原则之一是对值所具有的结构进行类型检查，它是对行为的抽象，具体行动需要有类去实现，一般接口<strong>首字母大写</strong></p>\n<pre><code class=\"language-ts\">interface Point {\n  x:number;\n  color?:string;  // 可选属性\n  readonly y:number;   // 只读属性\n  [propName: string]: any; // 额外的可选属性\n}\n</code></pre>\n<p><code>ReadonlyArray&#x3C;T></code>类型，它与<code>Array&#x3C;T></code>相似，只是把所有可变方法去掉了，确保数组创建后再也不能被修改\n<code>readonly</code> vs <code>const</code> : 属性用 <code>readonly</code> 变量用 <code>const</code></p>\n<h2>通过额外的属性检查</h2>\n<p>1.可以使用类型断言绕过这些检查</p>\n<pre><code class=\"language-ts\">let strLength:number = (&#x3C;string>someValue).length   //“尖括号”语法\nlet strLength1: number = (someValue as string).length    //一个为 `as` 语法\n</code></pre>\n<p>2.使用索引签，对象赋值给另一个变量，对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候</p>\n<pre><code class=\"language-ts\">let squareOptions = { colour: \"red\", width: 100 }\nlet mySquare = createSquare(squareOptions)\n</code></pre>\n<p>3.添加字符串索引签名</p>\n<pre><code>interface SquareConfig {\n  color?:string;\n  width?:number;\n  [propName:string]:any; // 额外的属性检查\n}\n</code></pre>\n<h2>接口描述函数类型</h2>\n<pre><code class=\"language-ts\">interface SearchFunc {\n  (source:string,subString:string):boolean;\n}\nlet MySearch:SearchFunc;\nMySearch = function(source:string,subString:string) {\n  let result = source.search(subString);\n  return result > -1\n}\n</code></pre>\n<h2>可索引的类型</h2>\n<pre><code class=\"language-ts\">interface StringArray {\n  [index:number]:string // 定义数组索引\n}\nlet myArray:StringArray = [\"Bob\",'Fred']\n\n// 索引匹配\ninterface NumberDictionary {\n  [index: string]: number; //定义索引匹配\n  length: number;    // 可以，length是number类型\n  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n\n// 索引只读\ninterface ReadonlyStringArray {\n    readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];\nmyArray[2] = \"Mallory\"; // error! 索引签名是只读的\n</code></pre>\n<h2>类类型</h2>\n<p> 使用关键字 <code>implements</code> </p>\n<pre><code class=\"language-ts\">interface ClockInterface {\n    currentTime: Date;\n    setTime(d: Date);\n}\n\nclass Clock implements ClockInterface {\n    currentTime: Date;\n    setTime(d: Date) {\n        this.currentTime = d;\n    }\n    constructor(h: number, m: number) { }\n}\n</code></pre>\n<h2>继承接口</h2>\n<p>关键字<code>extends</code></p>\n<pre><code class=\"language-ts\">interface Shape {\n  color:string;\n}\ninterface PenStroke {\n  penWidth:number;\n}\ninterface Square extends Shape,PenStroke {\n  sideLength:number\n}\nlet square = &#x3C;Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n</code></pre>\n<p><code>extends</code> 是继承某个类, 继承之后可以使用父类的方法, 也可以重写父类的方法;</p>\n<p><code>implements</code> 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用</p>","frontmatter":{"title":"接口"}}},"pageContext":{"slug":"/notes/接口/","tagPath":"/Typescript/接口/"}}