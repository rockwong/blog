{"data":{"markdownRemark":{"html":"<h1>dva 知识集</h1>\n<blockquote>\n<p><a href=\"https://github.com/dvajs/dva-knowledgemap\">https://github.com/dvajs/dva-knowledgemap</a></p>\n</blockquote>\n<h4>定义全局 CSS</h4>\n<p>CSS Modules 默认是局部作用域的，想要声明一个全局规则，可用 <code>:global</code> 语法。</p>\n<p>比如：</p>\n<pre><code class=\"language-css\">.title {\n  color: red;\n}\n:global(.title) {\n  color: green;\n}\n</code></pre>\n<p>然后在引用的时候：</p>\n<pre><code class=\"language-javascript\">&#x3C;App className={styles.title} /> // red\n&#x3C;App className=\"title\" />        // green\n</code></pre>\n<h4><code>classnames</code> Package</h4>\n<p>在一些复杂的场景中，一个元素可能对应多个 className，而每个 className 又基于一些条件来决定是否出现。这时，<a href=\"https://github.com/JedWatson/classnames\">classnames</a> 这个库就非常有用。</p>\n<pre><code class=\"language-javascript\">import classnames from 'classnames';\nconst App = (props) => {\n  const cls = classnames({\n    btn: true,\n    btnLarge: props.type === 'submit',\n    btnSmall: props.type === 'edit',\n  });\n  return &#x3C;div className={ cls } />;\n}\n</code></pre>\n<p>这样，传入不同的 type 给 App 组件，就会返回不同的 className 组合：</p>\n<pre><code class=\"language-javascript\">&#x3C;App type=\"submit\" /> // btn btnLarge\n&#x3C;App type=\"edit\" />   // btn btnSmall\n</code></pre>\n<h2>Reducer</h2>\n<p>reducer 是一个函数，接受 state 和 action，返回老的或新的 state 。即：<code>(state, action) => state</code></p>\n<h3>增删改</h3>\n<p>以 todos 为例。</p>\n<pre><code class=\"language-javascript\">app.model({\n  namespace: 'todos',\n  state: [],\n  reducers: {\n    add(state, { payload: todo }) {\n      return state.concat(todo);\n    },\n    remove(state, { payload: id }) {\n      return state.filter(todo => todo.id !== id);\n    },\n    update(state, { payload: updatedTodo }) {\n      return state.map(todo => {\n        if (todo.id === updatedTodo.id) {\n          return { ...todo, ...updatedTodo };\n        } else {\n          return todo;\n        }\n      });\n    },\n  },\n};\n</code></pre>\n<h3>嵌套数据的增删改</h3>\n<p>建议最多一层嵌套，以保持 state 的扁平化，深层嵌套会让 reducer 很难写和难以维护。</p>\n<pre><code class=\"language-javascript\">app.model({\n  namespace: 'app',\n  state: {\n    todos: [],\n    loading: false,\n  },\n  reducers: {\n    add(state, { payload: todo }) {\n      const todos = state.todos.concat(todo);\n      return { ...state, todos };\n    },\n  },\n});\n</code></pre>\n<p>下面是深层嵌套的例子，应尽量避免。</p>\n<pre><code class=\"language-javascript\">app.model({\n  namespace: 'app',\n  state: {\n    a: {\n      b: {\n        todos: [],\n        loading: false,\n      },\n    },\n  },\n  reducers: {\n    add(state, { payload: todo }) {\n      const todos = state.a.b.todos.concat(todo);\n      const b = { ...state.a.b, todos };\n      const a = { ...state.a, b };\n      return { ...state, a };\n    },\n  },\n});\n</code></pre>\n<h2>Effect</h2>\n<p>示例：</p>\n<pre><code class=\"language-javascript\">app.model({\n  namespace: 'todos',\n  effects: {\n    *addRemote({ payload: todo }, { put, call }) {\n      yield call(addTodo, todo);\n      yield put({ type: 'add', payload: todo });\n    },\n  },\n});\n</code></pre>\n<h3>Effects</h3>\n<h4>put</h4>\n<p>用于触发 action 。</p>\n<pre><code class=\"language-javascript\">yield put({ type: 'todos/add', payload: 'Learn Dva' });\n</code></pre>\n<h4>call</h4>\n<p>用于调用异步逻辑，支持 promise 。</p>\n<pre><code class=\"language-javascript\">const result = yield call(fetch, '/todos');\n</code></pre>\n<h4>select</h4>\n<p>用于从 state 里获取数据。</p>\n<pre><code class=\"language-javascript\">const todos = yield select(state => state.todos);\n</code></pre>\n<h3>错误处理</h3>\n<h4>全局错误处理</h4>\n<p>dva 里，effects 和 subscriptions 的抛错全部会走 <code>onError</code> hook，所以可以在 <code>onError</code> 里统一处理错误。</p>\n<pre><code class=\"language-javascript\">const app = dva({\n  onError(e, dispatch) {\n    console.log(e.message);\n  },\n});\n</code></pre>\n<p>然后 effects 里的抛错和 reject 的 promise 就都会被捕获到了。</p>\n<h4>本地错误处理</h4>\n<p>如果需要对某些 effects 的错误进行特殊处理，需要在 effect 内部加 <code>try catch</code> 。</p>\n<pre><code class=\"language-javascript\">app.model({\n  effects: {\n    *addRemote() {\n      try {\n        // Your Code Here\n      } catch(e) {\n        console.log(e.message);\n      }\n    },\n  },\n});\n</code></pre>\n<h3>异步请求</h3>\n<p>异步请求基于 whatwg-fetch，API 详见：<a href=\"https://github.com/github/fetch\">https://github.com/github/fetch</a></p>\n<h4>GET 和 POST</h4>\n<pre><code class=\"language-javascript\">import request from '../util/request';\n\n// GET\nrequest('/api/todos');\n\n// POST\nrequest('/api/todos', {\n  method: 'POST',\n  body: JSON.stringify({ a: 1 }),\n});\n</code></pre>\n<h4>统一错误处理</h4>\n<p>加入约定后台返回以下格式时，做统一的错误处理。</p>\n<pre><code class=\"language-javascript\">{\n  status: 'error',\n  message: '',\n}\n</code></pre>\n<p>编辑 <code>utils/request.js</code>，加入以下中间件：</p>\n<pre><code class=\"language-javascript\">function parseErrorMessage({ data }) {\n  const { status, message } = data;\n  if (status === 'error') {\n    throw new Error(message);\n  }\n  return { data };\n}\n</code></pre>\n<p>然后，这类错误就会走到 <code>onError</code> hook 里。</p>\n<h2>Subscription</h2>\n<p><code>subscriptions</code> 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。格式为 <code>({ dispatch, history }, onError) => unsubscribe</code> 。</p>\n<h3>异步数据初始化</h3>\n<p>比如：当用户进入 <code>/users</code> 页面时，触发 action <code>users/fetch</code> 加载用户数据。</p>\n<pre><code class=\"language-javascript\">app.model({\n  subscriptions: {\n    setup({ dispatch, history }) {\n      history.listen(({ pathname }) => {\n        if (pathname === '/users') {\n          dispatch({\n            type: 'users/fetch',\n          });\n        }\n      });\n    },\n  },\n});\n</code></pre>\n<h4><code>path-to-regexp</code> Package</h4>\n<p>如果 url 规则比较复杂，比如 <code>/users/:userId/search</code>，那么匹配和 userId 的获取都会比较麻烦。这是推荐用 <a href=\"https://github.com/pillarjs/path-to-regexp\">path-to-regexp</a> 简化这部分逻辑。</p>\n<pre><code class=\"language-javascript\">import pathToRegexp from 'path-to-regexp';\n\n// in subscription\nconst match = pathToRegexp('/users/:userId/search').exec(pathname);\nif (match) {\n  const userId = match[1];\n  // dispatch action with userId\n}\n</code></pre>\n<h2>Router</h2>\n<h3>Config with JSX Element (router.js)</h3>\n<pre><code class=\"language-javascript\">&#x3C;Route path=\"/\" component={App}>\n  &#x3C;Route path=\"accounts\" component={Accounts}/>\n  &#x3C;Route path=\"statements\" component={Statements}/>\n&#x3C;/Route>\n</code></pre>\n<p>详见：<a href=\"https://github.com/reactjs/react-router/blob/master/docs/guides/RouteConfiguration.md\">react-router</a></p>\n<h3>Route Components</h3>\n<p>Route Components 是指 <code>./src/routes/</code> 目录下的文件，他们是 <code>./src/router.js</code> 里匹配的 Component。</p>\n<h4>通过 connect 绑定数据</h4>\n<p>比如：</p>\n<pre><code class=\"language-javascript\">import { connect } from 'dva';\nfunction App() {}\n\nfunction mapStateToProps(state, ownProps) {\n  return {\n    users: state.users,\n  };\n}\nexport default connect(mapStateToProps)(App);\n</code></pre>\n<p>然后在 App 里就有了 <code>dispatch</code> 和 <code>users</code> 两个属性。</p>\n<h4>Injected Props (e.g. location)</h4>\n<p>Route Component 会有额外的 props 用以获取路由信息。</p>\n<ul>\n<li>location</li>\n<li>params</li>\n<li>children</li>\n</ul>\n<p>更多详见：<a href=\"https://github.com/reactjs/react-router/blob/master/docs/API.md#injected-props\">react-router</a></p>\n<h3>基于 action 进行页面跳转</h3>\n<pre><code class=\"language-javascript\">import { routerRedux } from 'dva/router';\n\n// Inside Effects\nyield put(routerRedux.push('/logout'));\n\n// Outside Effects\ndispatch(routerRedux.push('/logout'));\n\n// With query\nrouterRedux.push({\n  pathname: '/logout',\n  query: {\n    page: 2,\n  },\n});\n</code></pre>\n<p>除 <code>push(location)</code> 外还有更多方法，详见 <a href=\"https://github.com/reactjs/react-router-redux#pushlocation-replacelocation-gonumber-goback-goforward\">react-router-redux</a></p>\n<h2>dva 配置</h2>\n<h3>Redux Middleware</h3>\n<p>比如要添加 redux-logger 中间件：</p>\n<pre><code class=\"language-javascript\">import createLogger from 'redux-logger';\nconst app = dva({\n  onAction: createLogger(),\n});\n</code></pre>\n<p>注：onAction 支持数组，可同时传入多个中间件。</p>\n<h3>history</h3>\n<h4>切换 history 为 browserHistory</h4>\n<pre><code class=\"language-javascript\">import { browserHistory } from 'dva/router';\nconst app = dva({\n  history: browserHistory,\n});\n</code></pre>\n<h4>去除 hashHistory 下的 _k 查询参数</h4>\n<pre><code class=\"language-javascript\">import { useRouterHistory } from 'dva/router';\nimport { createHashHistory } from 'history';\nconst app = dva({\n  history: useRouterHistory(createHashHistory)({ queryKey: false }),\n});\n</code></pre>","frontmatter":{"title":"dva 知识集"}}},"pageContext":{"slug":"/notes/dva 知识集/","tagPath":"/React/dva 知识集/"}}