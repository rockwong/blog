{"data":{"markdownRemark":{"html":"<h1>React 最佳实践</h1>\n<blockquote>\n<p>参考 <a href=\"https://segmentfault.com/a/1190000011434694\">https://segmentfault.com/a/1190000011434694</a></p>\n</blockquote>\n<h2>优化propTypes</h2>\n<p>babel-react-optimize 可以在发布到产品环境下，自动去掉propTypes的代码。</p>\n<h2>数据显示</h2>\n<p>筛选及请求更新数据放入fetch或者dispath then中</p>\n<h2>展示与容器组件 Presentational &#x26; Container</h2>\n<p><strong>Bad Simple</strong></p>\n<pre><code class=\"language-jsx\">class CommentList extends React.Component {\n  this.state = { comments: [] };\n\n  componentDidMount() {\n    fetchSomeComments(comments =>\n      this.setState({ comments: comments }));\n  }\n  render() {\n    return (\n      &#x3C;ul>\n        {this.state.comments.map(c => (\n          &#x3C;li>{c.body}—{c.author}&#x3C;/li>\n        ))}\n      &#x3C;/ul>\n    );\n  }\n}\n</code></pre>\n<p>数据抓取和数据展示同放在同一个组件和代码块中,数据抓取部分逻辑和数据展示逻辑都无法复用。把数据逻辑部分分离出来成为独立的组件，这类组件就是Container Components，而展现部分组件则是Presentational Components。</p>\n<p><strong>Presentational Components:</strong></p>\n<pre><code class=\"language-js\">const CommentList = props =>\n  &#x3C;ul>\n    {props.comments.map(c => (\n      &#x3C;li>{c.body}—{c.author}&#x3C;/li>\n    ))}\n  &#x3C;/ul>\n</code></pre>\n<p><strong>Container Components:</strong></p>\n<pre><code class=\"language-js\">class CommentListContainer extends React.Component {\n  state = { comments: [] };\n  componentDidMount() {\n    fetchSomeComments(comments =>\n      this.setState({ comments: comments }));\n  }\n  render() {\n    return &#x3C;CommentList comments={this.state.comments} />;\n  }\n}\n</code></pre>\n<h2>有状态与无状态组件 Stateful &#x26; Stateless</h2>\n<p><strong>有状态组件</strong></p>\n<p>意思是这个组件能够获取储存改变应用或组件本身的状态数据，在React当中也就是state，一些比较明显的特征是我们可以在这样的组件当中看到对this.state的初始化，或this.setState方法的调用等等。</p>\n<pre><code class=\"language-js\">//Stateful Component\nclass StatefulLink extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      active: false\n    }\n  }\n  handleClick() {\n    this.setState({\n      active: !this.state.active\n    })\n  }\n  render() {\n    return &#x3C;a \n          style={{ color: this.state.active ? 'red' : 'black' }}\n          onClick={this.handleClick.bind(this)}\n         >\n           Stateful Link\n         &#x3C;/a>\n  }\n}\n</code></pre>\n<p><strong>无状态组件</strong></p>\n<p>这样的组件一般只接收来自其他组件的数据。一般这样的组件中只能看到对this.props的调用，通常可以用函数定义组件的方式声明。它本身不会掌握应用的状态数据，即使触发事件，也是通过事件处理函数传递到其他有状态组件当中再对state进行操作。</p>\n<pre><code class=\"language-js\">/ Stateless Component\nclass StatelessLink extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n  handleClick() {\n    this.props.handleClick(this.props.router)\n  }\n  render() {\n    const active = this.props.activeRouter === this.props.router\n    return (\n        &#x3C;li>\n            &#x3C;a \n              style={{ color: active ? 'red' : 'black' }}\n              onClick={this.handleClick.bind(this)}\n             >\n                Stateless Link\n            &#x3C;/a>\n    &#x3C;/li>\n    )\n  }\n}\n\nclass Nav extends React.Component {\n  constructor() {\n    super()\n    this.state={activeRouter: 'home'}\n  }\n  handleSwitch(router) {\n    this.setState({activeRouter: router})\n  }\n  render() {\n    return (\n    &#x3C;ul>\n        &#x3C;StatelessLink activeRouter={this.state.activeRouter} router='home' handleClick={this.handleSwitch.bind(this)} />\n        &#x3C;StatelessLink activeRouter={this.state.activeRouter} router='blog' handleClick={this.handleSwitch.bind(this)} />\n        &#x3C;StatelessLink activeRouter={this.state.activeRouter} router='about' handleClick={this.handleSwitch.bind(this)} />\n    &#x3C;/ul>\n    )\n  }\n}\n</code></pre>","frontmatter":{"title":"React 最佳实践"}}},"pageContext":{"slug":"/notes/React 最佳实践/","tagPath":"/React/React 最佳实践/"}}