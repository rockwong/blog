{"data":{"markdownRemark":{"html":"<h1>Ramda.js</h1>\n<h2>Function 相关接口</h2>\n<h3>complement</h3>\n<p>它传入一个函数，返回一个新的函数：当原函数返回 \"假值\" 时，新函数返回 true；原函数返回 \"真值\" 时，新函数返回 false</p>\n<h3>both/either 和 allPass/anyPass</h3>\n<p><code>both</code> 接受两个函数，返回一个新函数：当两个传入函数都返回 truthy 值时，新函数返回 true，否则返回 false\n<code>either</code> 接受两个函数，返回一个新函数：当两个传入函数任意一个返回 truthy 值时，新函数返回 true，否则返回 false\n<code>allPass/anyPass</code> 接受多个参数，allPass 类似于 both，而 anyPass 类似于 either</p>\n<h3>pipe/compose</h3>\n<p><code>pipe</code> 函数：接受一系列函数，并返回一个新函数,执行顺序从左到右\n<code>compose</code> 类似 pipe 执行顺序相反</p>\n<h3>partial/partialRight</h3>\n<p>返回一个接受剩余参数的新函数，当所有参数都传入后，才会真正调用被包裹的原函数\n<code>partial</code> 和 <code>partialRigth</code>的区别是参数传递的顺序</p>\n<p><strong>包裹函数提供的参数必须包裹在数组中</strong></p>\n<h3>curry</h3>\n<ul>\n<li>可以按正常情况下使用所有参数调用它，它可以像普通函数一样正常工作；</li>\n<li>也可以使用部分参数来调用它，这时它会像使用 partial 一样工作。</li>\n</ul>\n<h2>Type 类型判断</h2>\n<p><code>isEmpty</code> 检测给定值是否为其所属类型的空值，若是则返回 true ；否则返回 false </p>\n<pre><code class=\"language-js\">R.isEmpty([1, 2, 3]);   //=> false\nR.isEmpty([]);          //=> true\nR.isEmpty('');          //=> true\nR.isEmpty(null);        //=> false\nR.isEmpty({});          //=> true\nR.isEmpty({length: 0}); //=> false\n</code></pre>\n<p><code>isNil</code> -><code>null || undefined</code>\n<code>equals</code> -> <code>===</code>\n<code>gt</code> \t-> <code>></code>\n<code>lt</code> \t-> <code>&#x3C;</code>\n<code>lte</code> \t-> <code>&#x3C;=</code>\n<code>gte</code> \t-> <code>>=</code></p>\n<h2>Logic 逻辑相关</h2>\n<p><code>defaultTo</code> 检查第二个参数是否为空（isNil）。如果非空，则返回该值；否则返回第一个值</p>\n<h2>always 常量</h2>\n<p>返回一个返回恒定值的函数\n<code>T</code> 和 <code>F</code>，是 <code>always(true)</code> 和 <code>always(false)</code> 的缩写</p>\n<pre><code class=\"language-js\">var t = R.always('Tee');\nt(); //=> 'Tee'\n</code></pre>\n<h2>filter/reject</h2>\n<p>reject 是 filter 的补操作。它保留使断言函数返回 \"falsy\" 的元素，排除使断言函数返回 \"truthy\" 的元素</p>","frontmatter":{"title":"Ramda.js"}}},"pageContext":{"slug":"/notes/Ramda.js/","tagPath":"/Javascript/Ramda.js/"}}