{"data":{"markdownRemark":{"html":"<h1>类型的兼容性</h1>\n<p>各种类型系统之间的兼容性</p>\n<h2>结构化类型</h2>\n<p>如果<code>x</code>要兼容<code>y</code>，那么<code>y</code>至少具有与<code>x</code>相同的属性</p>\n<pre><code class=\"language-ts\">interface Named {\n    name: string;\n}\n\nlet x: Named;\n// y's inferred type is { name: string; location: string; }\nlet y = { name: 'Alice', location: 'Seattle' };\nx = y;\n</code></pre>\n<h2>比较函数</h2>\n<p>一 .  <code>比较参数类型</code> 目标函数 <code>x</code>的每个参数必须能在<code>y</code>里找到对应类型的参数</p>\n<pre><code class=\"language-ts\">let x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\n\ny = x; // OK\nx = y; // Error\n</code></pre>\n<p>二 . <code>比较返回值类型</code> 目标函数 <code>x</code>的返回值必须是<code>y</code>返回值的父类</p>\n<pre><code class=\"language-ts\">let x = () => ({name: 'Alice'});\nlet y = () => ({name: 'Alice', location: 'Seattle'});\n\nx = y; // OK\ny = x; // Error because x() lacks a location property\n</code></pre>\n<h2>枚举</h2>\n<p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。</p>\n<pre><code class=\"language-ts\">enum Status { Ready, Waiting };\nenum Color { Red, Blue, Green };\n\nlet status = Status.Ready;\nstatus = Color.Green;  //error\n</code></pre>\n<h2>类</h2>\n<p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p>\n<pre><code class=\"language-ts\">class Animal {\n    feet: number;\n    constructor(name: string, numFeet: number) { }\n}\nclass Size {\n    feet: number;\n    constructor(numFeet: number) { }\n}\nlet a: Animal;\nlet s: Size;\n\na = s;  //OK\ns = a;  //OK\n</code></pre>","frontmatter":{"title":"类型的兼容性"}}},"pageContext":{"slug":"/notes/类型的兼容性/","tagPath":"/Typescript/类型的兼容性/"}}