{"data":{"markdownRemark":{"html":"<h1>react-redux</h1>\n<h2>Provider</h2>\n<p><code>Provider</code>这个模块是作为整个<code>App</code>的容器,接受Redux的store作为props。\n并将其声明为<code>context</code>的属性之一，子组件可以在声明了<code>contextTypes</code>之后可以方便的通过<code>this.context.store</code>访问到<code>store</code>。不过我们的组件通常不需要这么做，将<code>store</code>放在<code>context</code>里，是为了给下面的<code>connect</code>用的。</p>\n<pre><code class=\"language-js\">// config app root\nconst history = createHistory()  \nconst root = (  \n  &#x3C;Provider store={store} key=\"provider\">\n    &#x3C;Router history={history} routes={routes} />\n  &#x3C;/Provider>\n)\n\n// render\nReactDOM.render(  \n  root,\n  document.getElementById('root')\n)\n</code></pre>\n<h2>connect</h2>\n<p>Redux如何运作：首先<code>store</code>中维护了一个<code>state</code>，我们<code>dispatch</code>一个<code>action</code>，接下来<code>reducer</code>根据这个<code>action</code>更新<code>state</code>。</p>\n<p><strong>API如下：</strong>\n<code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code></p>\n<p><strong>mapStateToProps</strong>\n是一个函数，返回值表示的是需要merge进props的state。默认值为<code>() => ({})</code>，即什么都不传。</p>\n<pre><code class=\"language-js\">(state, props) => ({  }) // 通常会省略第二个参数\n</code></pre>\n<p><strong>mapDispatchToProps</strong>\n可以是一个函数，返回值表示的是需要merge仅props的actionCreators，这里的actionCreator应该是已经被包装了dispatch了的，推荐使用redux的bindActionCreators函数。</p>\n<pre><code class=\"language-js\">(dispatch, props) => ({ // 通常会省略第二个参数\n ...bindActionCreators({\n   ...ResourceActions\n }, dispatch)\n})\n</code></pre>\n<p><strong>mergeProps</strong>\n用于自定义merge流程，下面这个是默认流程，parentProps值的就是组件自身的props，可以发现如果组件的props上出现同名，会被覆盖。</p>\n<pre><code class=\"language-js\">(stateProps, dispatchProps, parentProps) => ({\n  ...parentProps,\n  ...stateProps,\n  ...dispatchProps\n})\n</code></pre>\n<p><strong>options</strong>\n共有两个开关：pure代表是否打开优化，详细内容下面会提，默认为true，withRef用来给包装在里面的组件一个ref，可以通过getWrappedInstance方法来获取这个ref，默认为false。</p>\n<p><code>connect</code>返回一个函数，它接受一个React组件的构造函数作为连接对象，最终返回连接好的组件构造函数。</p>\n<p>当<code>storeState</code>变化的时候，仅在我们真正依赖那部分state变化时，才重新render相应的React组件，那么什么是我们真正依赖的部分？就是通过<code>mapStateToProps</code>和<code>mapDispatchToProps</code>得到的</p>\n<p><strong>关于reducer</strong>\n一个函数,功能就是在action触发后，返回一个新的state(就是个对象)</p>\n<pre><code class=\"language-js\">export default (state = {}, action) => {  \n  return { ...state } // 返回的是一个新的对象，可能会使组件reRender\n  // return state // 可能不会使得组件reRender\n}\n</code></pre>\n<p><code>connect</code>的时候，要谨慎map真正需要的state或者actionCreators到props中，以避免不必要的性能损失</p>","frontmatter":{"title":"react-redux"}}},"pageContext":{"slug":"/notes/react-redux/","tagPath":"/React/react-redux/"}}