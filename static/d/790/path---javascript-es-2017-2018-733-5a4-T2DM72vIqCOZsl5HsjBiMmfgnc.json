{"data":{"markdownRemark":{"html":"<h1>ES 2017-2018</h1>\n<blockquote>\n<p>参考：\n<a href=\"http://es6.ruanyifeng.com/\">http://es6.ruanyifeng.com/</a>\n<a href=\"https://blog.hypers.io/2018/04/11/es2016-17-18/\">https://blog.hypers.io/2018/04/11/es2016-17-18/</a></p>\n</blockquote>\n<h2>指数运算</h2>\n<pre><code class=\"language-js\">// 不使用\nMath.pow(7,2) //49\n\n//使用\n7**2 //49\n</code></pre>\n<h2>数组的解构赋值</h2>\n<p>需要等号两边都是数组</p>\n<pre><code class=\"language-js\">    var [a, b, c] = [1, 2, 3];\n    let [foo, [[bar], baz]] = [1, [[2], 3]];\n    /* 容许有默认值,如果默认值是表达式,那么这个表达式是惰性求值 */\n    var [foo = true] = [];\n</code></pre>\n<h2>对象的解构赋值</h2>\n<pre><code class=\"language-js\">var { bar, foo } = { foo: \"aaa\", bar: \"bbb\" };\n</code></pre>\n<h2>Object.values()</h2>\n<p>与 <code>Object.keys()</code> 类似，返回自身所有值，排除原型链中的任何职</p>\n<pre><code class=\"language-js\">const cars = { 'BMW': 3, 'Tesla': 2, 'Toyota': 1 };\n\n//ES2017 and 未来\nconst values = Object.values(cars);\nconsole.log(values); // [3, 2, 1]\n</code></pre>\n<h2>Object.entries()</h2>\n<p>与<code>Object.keys</code>类似，以数组的方式返回 keys 和values.</p>\n<pre><code class=\"language-js\">const cars = { 'BMW': 3, 'Tesla': 2, 'Toyota': 1 };\n\n//ES2017 and 未来\nconst values = Object.entries(cars);\nconsole.log(values); // [[\"BMW\",3],[\"Tesla\",2],[\"Toyota\",1]]\n</code></pre>\n<h2>String padding</h2>\n<p>向字符串 – <code>String.prototype.padStart</code>和<code>String.prototype.padEnd</code>添加了两个实例方法 – 它们允许在原始字符串的开始或结尾附加/预先添加空字符串或其他字符串。</p>\n<p>语法： <code>'someString'.padStart(numberOfCharcters [,stringForPadding]);</code></p>\n<pre><code class=\"language-js\">/ES2017\n//如果你有一个不同长度的项目列表，并希望格式化它们的显示目的，你可以使用padStart\n\nconst formatted = [0, 1, 12, 123, 1234, 12345].map(num => \n    num.toString().padStart(10, '0') // 添加 0 直到长度为 10\n);\n\nconsole.log(formatted);\n\n//打印\n// [\n//  '0000000000',\n//  '0000000001',\n//  '0000000012',\n//  '0000000123',\n//  '0000001234',\n//  '0000012345',\n// ]\n</code></pre>\n<pre><code class=\"language-js\">const cars = {\n  '🚙BMW': '10',\n  '🚘Tesla': '5',\n  '🚖Lamborghini': '0'\n}\nObject.entries(cars).map(([name, count]) => {\n  //padEnd appends ' -' until the name becomes 20 characters\n  //padStart prepends '0' until the count becomes 3 characters.\n  console.log(`${name.padEnd(20, ' -')} Count: ${count.padStart(3, '0')}`)\n});\n//打印结果..\n// 🚙BMW - - - - - - -  Count: 010\n// 🚘Tesla - - - - - -  Count: 005\n// 🚖Lamborghini - - -  Count: 000\n</code></pre>\n<h2>字符串方法 includes(), startsWith(), endsWith()</h2>\n<ul>\n<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>\n<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>\n<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>\n</ul>\n<pre><code class=\"language-js\">var s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\ns.startsWith('world', 6) // true\ns.endsWith('Hello', 5) // true\ns.includes('Hello', 6) // false\n</code></pre>\n<h2>模板字符串</h2>\n<p>使用反引号 ( ` ),标识</p>\n<pre><code class=\"language-js\">// 普通字符串\n`In JavaScript '\\n' is a line-feed.`\n\n// 多行字符串\n`In JavaScript this is\n not legal.`\n\nconsole.log(`string text line 1\nstring text line 2`);\n\n// 字符串中嵌入变量\nvar name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n</code></pre>\n<h2>iterator</h2>\n<p><code>Array</code> <code>Map</code>  <code>Set</code>  <code>String</code> <code>TypedArray</code>  <code>函数的 arguments 对象</code>  <code>NodeList 对象</code> 原生具备 Iterator 接口。</p>\n<p><strong>for...of 循环</strong>\n与forEach 不同是， <code>for...of</code>容许获取键值，可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</p>\n<pre><code class=\"language-js\">for (let elem of ['a', 'b']) {\n  console.log(elem);\n}\n// a\n// b\n\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n</code></pre>\n<h2>修饰器 Decorator</h2>\n<p><strong>修饰类</strong></p>\n<pre><code class=\"language-js\">@decorator\nclass A {}\n\n// 等同于\n\nclass A {}\nA = decorator(A) || A;\n</code></pre>\n<p><strong>方法的修饰</strong></p>\n<pre><code class=\"language-js\">class Math {\n  @log\n  add(a, b) {\n    return a + b;\n  }\n}\n// 类似于\n//Object.defineProperty(Math.prototype, 'add', descriptor);\n// descriptor对象原来的值如下\n// {\n//   value: specifiedFunction,\n//   enumerable: false,\n//   configurable: true,\n//   writable: true\n// };\n\nfunction log(target, name, descriptor) {\n  var oldValue = descriptor.value;\n  descriptor.value = function() {\n    console.log(`Calling ${name} with`, arguments);\n    return oldValue.apply(null, arguments);\n  };\n\n  return descriptor;\n}\n\nconst math = new Math();\n\n// passed parameters should get logged now\nmath.add(2, 4);\n// Calling add with [2,4]\n</code></pre>\n<h2>Async/Await</h2>\n<pre><code class=\"language-js\">//异步函数本身返回一个Promise\nasync function doubleAndAdd(a, b) {\n    a = await doubleAfterlSec(a);\n    b = await doubleAfterlSec(b);\n    return a + b;\n}\n\n//用法\ndoubleAndAdd(1, 2).then(console.log);\n\nfunction doubleAfterlSec(param) {\n    return new Promise (resolve => {\n        setTimeout(resolve(param * 2), 1000);\n    });\n}\n</code></pre>\n<h2>Promise.prototype.finally()</h2>\n<p>finally() 是添加到Promise的新实例方法。他的主要想法是允许在解决或拒绝之后运行回调以帮助清理事情。finally回调被调用时没有任何价值，并且无论如何总是被执行。</p>\n<h2>正则表达式的“dotall”标志</h2>\n<p>虽然dot（“.”）应该匹配单个字符，但它不匹配像<code>\\n \\r \\f</code>等新行字符。</p>\n<pre><code class=\"language-js\">//之前\n/first.second/.test('first\\nsecond'); //false\n\n//ECMAScript 2018\n/first.second/s.test('first\\nsecond'); //true   Notice: /s 👈🏼\n</code></pre>","frontmatter":{"title":"ES 2017-2018"}}},"pageContext":{"slug":"/notes/ES 2017-2018/","tagPath":"/Javascript/ES 2017-2018/"}}